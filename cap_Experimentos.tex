%TCIDATA{LaTeXparent=0,0,relatorio.tex}
                      
\chapter{Elementos de Circuitos e Programação}\label{CapExperimentos}

% Resumo opcional. Comentar se não usar.
%\resumodocapitulo{Resumo opcional.}
\section{Introdução}

Este capítulo é destinado a explicação detalhada dos conceitos teóricos que embassam as práticas propostas no capítulo \ref{CapDesenvolvimento} deste trabalho.
\section{Circuitos eletrônicos}
\label{EmbassamentoHarware}

Nesta seção são tratados todos conceitos relativos a circuitos eletrônicos e hardwares que embassam as práticas propostas na seção \ref{CapExperimentos}.


\subsection{Resistor}
\label{EmbassamentoHarware_Resistor}

Num circuito elétrico, chama-se por resistor o elemento que oferece \textit{resistência} a passagem de corrente elétrica entre seus terminais. 

Resistores são elementos \textit{passivos} num circuito eletrônico. Isso significa que eles são apenas consumidores de energia. 	

Com o uso de resistores e suas ligações (subseções \ref{ligacaoSerie} e \ref{ligacaoParalelo}) , é possível controlar as correntes e tensões num circuito de forma a : limitar seus valores, ajustar nível de sinais, polarizar elementos ativos, entre outras diversas aplicações.

Tais funcionalidades do resistor estão sempre associadas à \textit{Lei de Ohm}, descrita com mais detalhes na seção \ref{leiOhm}.

A Figura \ref{resistor1} mostra um exemplo de resistor utilizado em circuitos eletrônicos. 

Há vários tipos de resistores fabricados de diversas maneiras e, como dito, para as mais diversas aplicações. O resistor mostrado na Figura \ref{resistor1} é chamado de resistor de valor fixo e geralmente é utilizado para prototipagem de circuitos eletrônicos. 

Resistores de valor fixo são geralmente fabricados utilizando carbono, metal, ou películas de óxidos metálicos. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/resistor1.jpg}
	\caption{Exemplo de resistor utilizado em circuitos eletrônicos.}
	\label{resistor1}
\end{figure}

A simbologia para resitores num circuito elétrico é também extensa. A Figura \ref{resistor2} mostra todos os tipos de simbologia utilizado para várias aplicações.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/resistor2.png}
	\caption{Simbolos de resistor utilizado em circuitos eletrônicos.}
	\label{resistor2}
	\source{www.vegyelgep.bme.hu}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/resistor3.jpg}
	\caption{Como ler o códido de cores de um resistor.}
	\label{resistor3}
	\source{http://education.rec.ri.cmu.edu/content/electronics/common/resistors/1.html}
\end{figure}

Resistores de valor fixo, como o mostrado na Figura \ref{resistor3}, tem como resistência a seguinte expressão: 	

\begin{equation}\label{eqResistenciaTabela}
R = (Digito_{1} + 10*Digito_{2})*Multiplicador \pm Tolerancia \% 
\end{equation}

Os valores \textit{$Digito_{1}$ , $Digito_{2}$, Multiplicador e Tolerência} são mostrados na Tabela \ref{tabCores} para cada cor utilizada no código.
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
	\centering
	\caption{Tabela de leitura de valor e tolerância de um resistor}
	\label{tabCores}
	\begin{tabular}{|c|c|c|l|c|}
		\hline
		Cor                             & Multiplicador                 & Dígito 1                 & Digito 2                 & {\color[HTML]{333333} Tolerância} \\ \hline
		\rowcolor[HTML]{000000} 
		{\color[HTML]{FFFFFF} Preto}    & {\color[HTML]{FFFFFF} $10^0$} & {\color[HTML]{FFFFFF} 0} & {\color[HTML]{FFFFFF} 0} & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{643403} 
		{\color[HTML]{FFFFFF} Marrom}   & {\color[HTML]{FFFFFF} $10^1$} & {\color[HTML]{FFFFFF} 1} & {\color[HTML]{FFFFFF} 1} & {\color[HTML]{FFFFFF} $\pm1\%$}   \\ \hline
		\rowcolor[HTML]{FE0000} 
		{\color[HTML]{FFFFFF} Vermelho} & {\color[HTML]{FFFFFF} $10^2$} & {\color[HTML]{FFFFFF} 2} & {\color[HTML]{FFFFFF} 2} & {\color[HTML]{FFFFFF} $\pm2\%$}   \\ \hline
		\rowcolor[HTML]{F56B00} 
		Laranja                         & $10^3$                        & 3                        & 3                        & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{FCFF2F} 
		{\color[HTML]{000000} Amarelo}  & {\color[HTML]{000000} $10^4$} & 4                        & 4                        & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{34FF34} 
		{\color[HTML]{FFFFFF} Verde}    & {\color[HTML]{FFFFFF} $10^5$} & 5                        & 5                        & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{3531FF} 
		{\color[HTML]{FFFFFF} Azul}     & {\color[HTML]{FFFFFF} $10^6$} & 6                        & 6                        & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{6200C9} 
		{\color[HTML]{FFFFFF} Violeta}  & {\color[HTML]{FFFFFF} $10^7$} & 7                        & 7                        & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{C0C0C0} 
		{\color[HTML]{FFFFFF} Cinza}    & {\color[HTML]{FFFFFF} $10^8$} & 8                        & 8                        & {\color[HTML]{333333} }           \\ \hline
		Branco                          & $10^9$                        & 9                        & 9                        & {\color[HTML]{333333} }           \\ \hline
		\rowcolor[HTML]{FFCB2F} 
		Ouro                            &                               &                          &                          & {\color[HTML]{333333} $\pm5\%$}   \\ \hline
		\rowcolor[HTML]{C0C0C0} 
		Prata                           &                               &                          &                          & {\color[HTML]{333333} $\pm10\%$}  \\ \hline
	\end{tabular}
\end{table}

Cada resistor tem um limite que corrente que pode circular entre seus terminais. Geralmente esse limite é dado em relação à potência dissipada. Para saber qual potência será dissipada num resistor com resistência de valor \textit{R Ohms} deve-se aplicar a seguinte fórmula:

\begin{equation}\label{eqPotencia}
\begin{split}
P = IU \text{(Potência dissipada num resistor de valor R)}
\end{split}
\end{equation}

Onde \textit{P} é a potência dissipada em \textit{Watts}, I é a corrente elétrica que passa no resistor em \textit{Ampéres} e \textit{U} é a tensão elétrica entre os terminais do resistor em \textit{Volts}.


 


\subsection{Circuito - fórmulas e topologias básicas}
\label{EmbassamentoHardware_circuito}

Nomea-se por circuito elétrico, um caminho fechado entre dois ou mais pontos formado por componentes eletrônicos no qual corrente elétrica pode circular. A Figura \ref{circuito1} mostra um circuito elétrico simples formado por uma bateria que fornece uma diferença de potencial (Tensão) entre seus terminais de valor \textit{\textbf{V} Volts} e um resistor com valor de resistência \textbf{\textit{R} Ohms}. 

Os pontos A e B da figura mostram, respectivamente, o ponto de maior potencial elétrico ( + da bateria) e o ponto de menor potencial elétrico (- da bateria).

 Para descrever o comportamento a dinâmica de tensões, correntes existem as seguintes leis:

\begin{itemize}
	\item Primeira lei de Kirchoff - Leis das Malhas
	\item Segunda lei de Kirchoff - Leis dos Nós
	\item Lei de Ohm
\end{itemize}

E para descrever a topologia dos circuitos, existem duas ligações básicas entre componentes a serem tradadas neste documento:

\begin{itemize}
	\item Ligação Série
	\item Ligação Paralelo
\end{itemize}


\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/circuito1.png}
	\caption{Circuito Simples.}
	\label{circuito1}
\end{figure}

\subsubsection{Primeira lei de Kirchoff - Leis das Nós}
\label{lei1Kirchoff}
A primeira lei de Kirchoff diz que a soma da correntes elétricas que entram num nó $I_{entram} $é igual a soma das correntes que saem, $ I_{saem}$, ou seja:
\begin{equation}\label{eqKirchoof1}
\sum I_{entram} = \sum I_{saem}
\end{equation}

Usando a Figura \ref{circuito3} como exemplo, a primeira, nesse caso, é escrita da seguinte forma:

\begin{equation}\label{eqKirchoof11}
 I_{1} + I_{3} = I_{2} + I_{4} + I_{5}
\end{equation}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/circuito3.jpg}
	\caption{Primeira Lei de Kirchoff.}
	\label{circuito3}
\end{figure}


\subsubsection{Segunda lei de Kirchoff - Leis das Malhas}
\label{lei2Kirchoff}
A segunda lei de Kirchoff diz que a soma das tensões $u_{i}$ num caminho fechado, num circuito elétrico é igual a zero, ou seja:

\begin{equation}\label{eqKirchoof2}
\sum u_{i} = 0
\end{equation}

Usando a Figura \ref{circuito2} como exemplo, onde as tensão em cada componentes são descritas pela letra \textbf{\textit{u}} ,a primeira lei Kirchoff é escrita na seguinte forma

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/circuito2.png}
	\caption{Segunda Lei Kirchhoff.}
	\label{circuito2}
\end{figure}

\begin{equation}\label{eqKirchoof22}
\begin{split}
u - u_{1} - u_{2} = 0 \\
u = u_{1} + u_{2}
\end{split}
\end{equation}


\subsubsection{Lei de Ohm}
\label{leiOhm}

A lei de Ohm\cite{livro:Sedra} diz que num circuito fechado, sob um componente eletrônico que com valor resistência \textit{R} que esteja submetido a uma diferença de potencial entre seus terminais de valor \textit{V}, circulará uma corrente elétrica de \textit{I} segundo a seguinte fórmula:
\begin{equation}
I = \frac{V}{R}
\end{equation}

Essa expressão não depende da natureza de tal condutor: ela é válida para todos os condutores. Para um dispositivo condutor que obedeça à lei de Ohm, a diferença de potencial aplicada é proporcional à corrente elétrica, isto é, a resistência é independente da diferença de potencial e da corrente. Um dispositivo muito utilizado em aparelhos eletrônicos, como rádios, televisores e amplificadores, que obedece à essa lei é o resistor (componente descrito mais detalhadamente na seção \ref{Embassamento_resitor}) cuja função é controlar a intensidade de corrente elétrica que passa pelo aparelho.

Entretanto, para alguns materiais, por exemplo os semicondutores, a resistência elétrica não é constante, mesmo que a temperatura seja, ela depende da diferença de potencial V. Estes são denominados condutores não ôhmicos. Um exemplo de componente eletrônico que não obedece à lei de Ohm é o diodo(componente descrito mais detalhadamente na seção \ref{Embassamento_LED}).

\subsubsection{Ligação em Série}
\label{ligacaoSerie}
Quando dois ou mais componentes estão conectados num circuito, um após ao outro, diz que tais componentes estão conectados em série, como mostrado em \ref{circuito4}. 


\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/circuito4.png}
	\caption{Ligação em série de n resistores.}
	\label{circuito4}
\end{figure}

Para elementos que se encontram em série, a mesma corrente \textit{I} os percorre, como mostrado na Figura \ref{circuito5}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/circuito5.png}
	\caption{Mesma corrente percorrendo resistores em série.}
	\label{circuito5}
\end{figure}

Aplicando a segunda lei de Kirchoff, apresentada na seção \ref{lei2Kirchoff}, e a lei de Ohm, apresentada na seção \ref{leiOhm}, tem-se a seguinte sequência de expressões para a demonstração da resistência equivalente de resistores em série: 


\begin{equation}\label{eqSerie1}
\begin{split}
V_{+} - V_{-} = V_{R1} + V_{R2} + ... V_{Rn}   \quad \text{(Aplicando a lei de Kirchoff das malhas)}
\end{split}
\end{equation}


\begin{equation}\label{eqSerie2}
\begin{split}
I*R_{eq} = I*(R1 + R2 + ... Rn )   \quad \text{( Aplicando a Lei de Ohm)}
\end{split}
\end{equation}


\begin{equation}\label{eqSerie3}
\begin{split}
R_{eq} = (R1 + R2 + ... Rn )   \quad \text{( Fórmula de resistor equivalente - ligação série)}
\end{split}
\end{equation}

A resistência equivalente de uma ligação em série de resistores pode ser vista como a "resistência enxergada" pela fonte de diferença de potencial entre os pontos V+ e V- mostrados na Figura \ref{circuito5}.



\subsubsection{Ligação em Paralelo}
\label{ligacaoParalelo}
Numa conexão em paralelo, os componentes se encontram conectados com seus terminais conectados em comum e possuem sobre eles a mesma tensão elétrica, como mostrado na Figura \ref{circuito6}.

A primeira lei de Kirchoff, como mostrado na seção \ref{lei1Kirchoff}, mostra que a soma das correntes que entram num nó é igual a soma das correntes que por ele saem. 

Na Figura \ref{circuito6}, os resistores $R_{1}$, $R_{2}$,...$R_{n}$ encontram em paralelo. A soma das correntes que entram no nó A e igual a soma das correntes que dele saem, ou seja: 

\begin{equation}\label{eqParalelo1}
\begin{split}
I = I_{1} + I_{2} + ... +I_{n}  \quad \text{(Primeira Lei de Kirchoff)}
\end{split}
\end{equation}

Utilizando a Lei de Ohm e sabendo que, numa ligação em paralelo, todos elementos encontram-se sob a mesma Tensão elétrica, tem-se que:

\begin{equation}\label{eqParalelo2}
\begin{split}
\frac{V_{in}}{R_{eq}} = \frac{V_{in}}{R_{1}} + \frac{V_{in}}{R_{2}} + ... \frac{V_{in}}{R_{n}}  \quad \text{(Lei de Ohm aplicada à ligação em paralelo)}
\end{split}
\end{equation}

Disso, tem -se que:

\begin{equation}\label{eqSerie3}
\begin{split}
\frac{1}{R_{eq}} = \frac{1}{R_{1}} + \frac{1}{R_{2}} + ... \frac{1}{R_{n}}  \quad \text{( Fórmula de resistor equivalente - ligação paralelo)}
\end{split}
\end{equation}


\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/circuito6.png}
	\caption{Componentes conectados em paralelo.}
	\label{circuito6}
\end{figure}

\subsubsection{Resumo - Ligação em série X paralelo}
\label{ResumoSerieEParalelo}

A tabela mostrada em \ref{tabResumoSerieParaleo} o resumo das característica da ligação em série e da ligação em paralelo entre resistores:

\begin{table}[]
	\centering
	\caption{Resumo - Ligação em série X Ligação em paralelo}
	\label{tabResumoSerieParaleo}
	\begin{tabular}{l|l|l|l|}
		\cline{2-4}
		& \textbf{\begin{tabular}[c]{@{}l@{}}Tensão elétrica\\  nos elementos\end{tabular}} & \textbf{\begin{tabular}[c]{@{}l@{}}Corrente elétrica \\ pelos elementos\end{tabular}} & \textbf{\begin{tabular}[c]{@{}l@{}}Resistência Equivalente entre\\ N elementos conectados\end{tabular}} \\ \hline
		\multicolumn{1}{|l|}{\textbf{Ligação em Série}}    & Diferente                                                                         & Igual                                                                                 & $R_{eq} = R_{1} + R_{2} + ... + R_{n}$                                                                  \\ \hline
		\multicolumn{1}{|l|}{\textbf{Ligação em Paralelo}} & Igual                                                                             & Diferente                                                                             & $\frac{1}{R_{eq}} = \frac{1}{R_{1}} + \frac{1}{R_{2}} + ... \frac{1}{R_{n}}$                            \\ \hline
	\end{tabular}
\end{table}


\subsection{Diodo-LED}
\label{EmbassamentoHardware_LED}


Um \textbf{Diodo Emissor de Luz} (LED) é um dispositivo semicondutor o qual, ao passar de corrente elétrica do seu \textit{Ánodo} para seu \textit{Cátodo} emite luz. A Figura \ref{LED1} mostra o símbolo de um LED.

Como todo diodo, o LED bloqueia a passagem de corrente elétrica na direção do seu cátodo ao seu ánodo e permite a passagem de corrente na direção contrária.

Como mostrado na Figira \ref{LED0}, diodo são construídos com duas junções de semicondutores dopados: uma junção N e uma junção P. A junção P possui falta de portadores negativos, ou seja, está positivamente dopado. A junção N possui excesso de portadores negativos, ou seja, está negativamente dopada. 

A dinâmica dos portadores entre as junções N - P criem o comportamento de bloqueio e liberação da passagem de corrente no diodo. 

Para um diodo com tensão positiva entre ánodo e cátodo, existe uma região chamada região de depleção a qual deve ser superada para que exista fluxo de corrente, ainda que o diodo esteja positivamente polarizado, como mostrado também no gráfico da Figura \ref{LED2}.

\begin{figure}[H]
	\centering
	\includegraphics[width= 1\textwidth]{figs/LED0.png}
	\caption{Junção N-P em um diodo.}
	\label{LED0}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/diodo1.png}
	\caption{Símbolo Diodo}
	\label{LED1}
\end{figure}

A  Figura \ref{LED2} mostra a relação entre tensão aplicada entre o ánodo e o cátodo e a corrente que atravessa um diodo. Quando a diferença de tensão entre ânodo e cátodo é positiva, o diodo se encontra sob polarização direta. Nessa polarização, o diodo permite passagem de corrente entre seus terminais. A fórmula que expressa essa relação é a seguinte:


\begin{equation}\label{eqDiodo1}
\begin{split}
i_{D} = I_{s}(e^{v_{d}/nkT} - 1) 
\end{split}
\end{equation}

Onde $i_{D}$ é a corrente se passar pelo diodo, $v_{D}$ é a tensão entre ânodo e cátodo, T é a temperatura, k é a constante de Boltzmann, N é o coeficiente de não linearidade e $I_{s}$ é a corrente de saturação.

Como mostrado na Figura \ref{LED2}, quando em polarização reversa, o diodo não permite passagem de corrente com intensidade apreciável. 

Caso a diferença de tensão entre cátodo e ânodo seja maior que a tensão de quebra $V_{br}$, o diodo entrará na região de quebra e não mais bloqueará a passagem de corrente.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figs/LED2.png}
	\caption{Relação tensão, corrente num diodo e suas regiões de operação}
	\label{LED2}
	\source{$http://www2.feg.unesp.br/Home/PaginasPessoais/ProfMarceloWendling/2---diodo-semicondutor.pdf$}
\end{figure}

Para aplicações simples em eletrônica, usualmente se adota um modelo simplificado para a operação do diodo mostrado na Figura \ref{LED3}. 

Nesse modelo, para uma polarização direta, o diodo é substituído por um diodo ideal (sem queda de tensão) com uma bateria em série com valor de tensão de 0.7 a 0.6 de tensão significando a queda de tensão entre os terminais do diodo. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figs/LED3.jpg}
	\caption{Modelo simplificado de um diodo em polarização direta.}
	\label{LED3}
	\source{https://digitalsignal.files.wordpress.com/2008/09/aula05.pdf}
\end{figure}

Diodo são utilizados em várias aplicações em eletrônica. Alguns exemplo de aplicações seriam:

\begin{itemize}
	\item Retificação de tensão (Transformação de um sinal AC (Corrente Alternada) para DC (Corrente Contínua))
	\item Isolamento de sinais de fonte de potência
	\item Referência de voltagem
	\item Controle e limitação da amplitude de sinais
	\item Detecção de sinais
\end{itemize}

\subsection{Protoboard}
\label{EmbassamentoHardware_Protoboard}

Protoboard ou \textit{BreadBoard} é um componente essencial na prototipação de circuitos eletrônicos. Com uma protoboard, é possível criar circuitos temporários, sem necessidade de realizar soldagem. 

As protoboards foram criadas para simplificar a prototipação e testes de circuitos eletrônicos anteriormente a sua efetiva produção por meio em máquinas de circuitos impress
Em geral, as protoboards apresentam a estrutura mostrada na Figura \ref{protoboard1}. As trilhas verticais + e - marcadas na Figura são trilhas contínuas de alumínio. Usualmente, mas não obrigatoriamente, as trilhas + e - são usadas como para os polos positivo e negativo da bateria. A região central, com as trilhas na horizontal, geramente é utilizada para a construção do circuito desejado.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/protoboard1.jpg}
	\caption{Protoboard.}
	\label{protoboard1}
	\source{https://learn.sparkfun.com/tutorials/how-to-use-a-breadboard}
\end{figure}

A Figura \ref{protoboard3} mostra o esquemático de circuito simples formado por uma fonte de 9V, uma resistor de 1k ohm e um LED e sua construção numa protoboard.

Na parte direita da Figura \ref{protoboard3}, é mostrado os polos positivo e negativos da bateria de 9V conectado à trilha contínua e a região central foi usada para conectar tais polos ao LED e resistor em série. Além disso, a parte direita da Figura mostra o sentido convencional da corrente elétrica. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figs/protoboard3.jpg}
	\caption{Esquemático de um circuito e sua construção numa protoboard.}
	\label{protoboard3}
\end{figure}




\subsection{Divisor de tensão}
\label{EmbassamentoHardware_DivisorTesao}

Em eletrônica, chama-se divisor de tensão um circuito com estrutura similar ao mostrada na Figura \ref{divisorTensao1}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/divisor1.png}
	\caption{Modelo de um circuito divisor de tensão}
	\label{divisorTensao1}
\end{figure}

Pela segunda lei de Kirchoff (seção \ref{lei2Kirchoff}) tem-se a seguinte expressão:

\begin{equation}\label{eqDivisorTensao1}
\begin{split}
V_{in} - V_{R1} - V_{R2} = 0
\end{split}
\end{equation}



A corrente que circulará nesse circuito é igual a: 

\begin{equation}\label{eqDivisorTensao2}
\begin{split}
I = \frac{V_{in}}{(R1 + R2)}
\end{split}
\end{equation}

Calculando o valor da tensão de saída, tem-se:

\begin{equation}\label{eqDivisorTensao3}
\begin{split}
V_{out} = V_{in} - I*R1
\end{split}
\end{equation}

Portanto, a tensão de saída será igual a:


\begin{equation}\label{eqDivisorTensao4}
\begin{split}
V_{out} = \frac{R2}{R1 + R2} * V_{in} 
\end{split}
\end{equation}


O fator $\frac{R2}{R1 + R2}$ é o fator da divisão de tensão, no circuito exemplificado pela Figura \ref{divisorTensao1}.

Divisores de tensão tem várias aplicações em eletrônica, dentre elas, destacam-se as seguintes:

\begin{itemize}
	\item \textbf{Medição de sensores}: Um divisor de tensão pode ser usado como forma de medição para sensores resistivos ( Sensores que alteram sua resistência de acordo com o fator de sensitividade). 
	
	\item \textbf{Medição de altas tensões}: Um divisor de tensão pode ser usado para utilizar voltímetros para tensões além de sua respectivas escala de medição.
	
	\item \textbf{Mudança de escala de sinais}: Um divisor de tensão pode ser usado para adeguar a escala de um sinal para sinais que podem ser lidos e processados por um microprocessador em suas faixa operação própria.

\end{itemize}

\subsection{Potenciômetro}
\label{EmbassamentoHardware_Potenciometro}
Um potenciômetro é um componente de circuitos elétricos que possui resistência elétrica ajustável mecanicamente. Num esquemático de um circuito, o símbolo usado para potenciômetro é mostrado na Figura \ref{potenciometro1}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/potenciometro1.png}
	\caption{Símbolo de um potenciômetro.}
	\label{potenciometro1}
\end{figure}

Potenciômetros são muito usados para controlar / alterar as características de entrada / saída de aparelhos eletrônicos, como volume, balanço, graves, brilho, contraste, cor, tempo de funcionamento (em tv's, dvd's, monitores, relógios, ... ).São também conhecidos como resistores variáveis, ou ainda, reostatos.

Para criar tal característica de variação de resistência, os potênciometros possuem internamente uma trilha resistiva (de níquel-cromo ou de carbono), sobre a qual desliza um  cursor , que altera a resistência elétrica entre seu conector central e um dos dois laterais(normalmente são três conectores).

Os potenciômetros podem ser classificados em duas categorias: quanto a forma de deslocamento do curso e quanto a forma de variação da resistências entre seus terminais.

Em relação a forma de deslizamento do curso, os potenciômetros podem ser angulares, Figura \ref{potenciometro2}, e lineares, Figura \ref{potenciometro4}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/potenciometro2.png}
	\caption{Estrutura de um potenciômetro angular.}
	\label{potenciometro2}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/potenciometro4.jpg}
	\caption{Potenciômetro linear.}
	\label{potenciometro4}
\end{figure}

Em relação a a forma de variação da resistência entre seus terminais, os potênciometros podem ter variação linear ou variação logarítimica. A Figura \ref{potenciometro5} mostra tais formas de variação.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/potenciometro5.jpg}
	\caption{Formas de variação da resistência em um potênciometro.}
	\label{potenciometro5}
\end{figure}

Assumindo que a resistência entreos terminais externos do potêncioemtro da Figura \ref{potenciometro3} é fixa e igual a 10 k ohms tem-se as seguintes formas de uso dos terminais:

\begin{itemize}
	\item \textbf{Ponteciômetro 1}: está com os terminais 1 e 2 ligados, neste caso ele varia sua resistência entre 0 ohm e 10 k ohms, nessa ligação quando o eixo é girado para a esquerda ele diminui a sua resistência e quando ele é girado  para a direita aumenta a sua resistência.
	\item \textbf{Ponteciômetro 2}: Nesse caso,os terminais 2 e 3 encontram-se ligados, ele varia sua resistência entre 0 ohm e 10 k ohms, nessa ligação quando o eixo é girado para a esquerda ele aumenta a sua resistência e quando é girado para a direita diminui a sua resistência.
	\item \textbf{Ponteciômetro 3}: a resistência é fixa, no caso 10 k ohms. Girar o curso não alterará a resistência observada.
	 
\end{itemize}



\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/potenciometro3.png}
	\caption{Formas de uso de um potênciometro angular. }
	\label{potenciometro3}
\end{figure}

Um exemplo de utilização de potenciômetros são os \textit{joysticks} utilizados em jogos eletrônicos. A Figura \ref{potenciometro7} mostra um circuito integrado de um joystick. 

O joystick mostrado é implementado utilizando dois potenciômetros. Um dos potenciômetros é traduz em tensão a posição X em relação à posição inicial e o outro traduz a posição Y.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/potenciometro7.jpg}
	\caption{Circuito integrado de um joystick que utiliza dois potenciômetros para tradução de sua posição em tensão. }
	\label{potenciometro7}
\end{figure}

A Figura \ref{potenciometro6} mostra um circuito esquemático utilizando um joystick construído com 2 potenciômetros.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{figs/potenciometro6.jpg}
	\caption{Circuito esquemático de um circuito utilizando um joystick similar ao mostrado na Figura \ref{potenciometro7} com a placa Galileo.}
	\label{potenciometro6}
\end{figure}

Para o circuito mostrado na Figura \ref{potenciometro6}, os potenciômetros estão sob 5V de tensão. Na posição inicial, ambas portas analógicas 0 e 1 ,que leêm as posições X e Y, lerão 2.5 V. Ao se movimentar o joystick, as portas analógicas lerão algum valor entre 0 e 5V.

\subsection{LDR}
\label{EmbassamentoHardware_LDR}

Um foto-resistor ou LDR (Light Dependent Resistor) é um resistor cuja resitência é dependente da luz que incide sobre ele. A Figura \ref{ldr1} mostra um LDR simples, muito utilizado em circuitos eletrônicos e a Figura \ref{ldr2} mostra a símbolo para o LDR usado em esquemáticos.  

Resistores dependentes de luz podem ser de diferentes tipos. Eles variam em material sensível à luz usada. Um resistor dependente da luz no espectro visívelé feita através de sulfureto de cádmio (CdS) ou seleneto de cádmio (CdSe). Este material é sensível ao comprimento de onda de 400 nm - 850 nm. Por perto faixa do infravermelho (1 \si\micro m - 3 \si\micro m), existem PBS ou materiais PBSE usado. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/ldr1.png}
	\caption{LDR}
	\label{ldr1}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figs/ldr3.jpg}
	\caption{Símbolo do LDR}
	\source{www.electrical4u.com}
	\label{ldr2}
\end{figure}

Um LDR pode de dezenas de Megaohms (Escuro) para algumas centenas de ohms (claro) dependendo da intensidade da luz incidente, como mostrado no gráfico da Figura \ref{ldr3}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/ldr2.jpg}
	\caption{Gráfico LDR : Resistência X Luminância}
	\source{www.electrical4u.com}
	\label{ldr3}
\end{figure}


Como dito na seção \ref{EmbassamentoHardware_DivisorTesao}, um divisor de tensão pode ser usado em conjunto com sensores resistivos como o LDR. A Figura \ref{ldr4} mostra um sensor de luz implementado com um circuito formado por uma fonte DC, um resistor fixo de 10k ohms e um LDR.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/ldr4.jpg}
	\caption{Possível circuito a ser utilizado num sensor de luz}
	\label{ldr4}
\end{figure}

 A tensão de saída \textit{Vout} é dada segundo a seguinte expressão: 
 
 \begin{equation}\label{eqLDR}
 \begin{split}
 V_{out} = \frac{10k}{10k + R_{LDR}} * 5 
 \end{split}
 \end{equation}
 
 Onde $R_{LDR}$ obedece ao gráfico mostrado na Figura \ref{ldr3}.

\subsection{Interruptores}
\label{interruptores}
Ao se desenvolver circuitos eletrônicos, existem duas expressões muita comuns: circuito aberto e circuito fechado. 

Um circuito aberto é mostrado na Figura \ref{interruptor1}. Nesse circuito, corrente alguma sai da fonte e passa pela lâmpada.

 Pode-se dizer que a região entre A e B é uma resistor com resistência que tende ao infinito. Usando essa suposição, ao se calcular a corrente que circula numa região de circuito aberto tem-se a seguinte expressão:

\begin{equation}\label{eqCircuitoAberto}
 \begin{split}
 I = \lim_{R_{AB}\to\infty} \frac{V_{bateria}}{R_{lampada} + R_{AB}} = 0 A 
 \end{split}
\end{equation}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/interruptor1.jpg}
	\caption{Circuito aberto.}
	\label{interruptor1}
\end{figure}


Um circuito fechado, é um circuito que se encontra caminho efetivo, para passagem de corrente elétrica. Na Figura \ref{interruptor2} é mostrado o mesmo circuito da Figura \ref{interruptor1} fechado.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/interruptor2.jpg}
	\caption{Circuito fechado.}
	\label{interruptor2}
\end{figure}


Abrir ou fechar uma região de um circuito ou ele por completo pode-ser feito utilizando interruptores ou chaves.

Interruptores ou chaves tem por propósito abrir ou fechar um circuito ou certa região de um circuito de acordo com a vontade de um agente externo. A Figura \ref{interruptor3} mostra o símbolo de um interruptor num circuito elétrico.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/interruptor3.jpg}
	\caption{Símbolo de um interruptor.}
	\label{interruptor3}
\end{figure}

Um tipo especial de interruptor é o botão. A Figura \ref{interruptor4} mostra a imagem e esquemático de mini botões. 

Os Mini Push Buttons são também chamados de interruptores tendenciosos ou momentâneos, porque após precionados, eles retornam ao estado de origem (aberto ou fechado).

Existem 2 tipos de Mini Botões de Pressão quanto ao seu estado:

\begin{itemize}
	\item NO (abreviação de Normally Open), esse interruptor momentâneo fica normalmente aberto (desligado), mas quando pressionado e segurado o botão, o interruptor fecha (liga). Ao soltar o botão, o interruptor abre novamente. Utilizado em teclados de computadores, calculadoras, etc.

\item NC (abreviação de Normally Closed), esse interruptor momentâneo fica normalmente fechado (ligado), mas quando apertado e segurado o botão, o interruptor abre (desliga). Ao soltar o botão, o interruptor fecha novamente. Utilizado na iluminação interna das geladeiras, veículos, etc. (ao abrir a porta, o interruptor é acionado, fechando o circuito). 
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/interruptor4.jpg}
	\caption{Mini botões de pressão, de 2 e 4 pinos.}
	\label{interruptor4}
	\source{$http://www.dreaminc.com.br/sala_de_aula/9b-interruptores-mini-botao-de-pressao/$}
\end{figure}

O mini botão de 4 pinos de contato é muitas vezes utilizado para oferecer tensão alta (HIGH) e baixa (LOW) para uma porta de uma placa como a placa Galileo.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/interruptor5.jpg}
	\caption{Circuito simples utilizando um botão de 4 pinos de contato .}
	\label{interruptor5}
\end{figure}

A Figura \ref{interruptor5} mostra um exemplo de um circuito construído em conjunto com a placa Galileo. Nesse circuito, a porta digital 2 pode ler um nível de tensão alta (HIGH) ou baixa(LOW) dependendo do botão estar pressionado ou não. Como mostrado no esquemático, quando o botão é pressionado, os ponto A e B se encostam e na porta digital passa a existir a tensão alta.

As aplicações para botões em eletrônica são diversas. Neste trabalho, muitas práticas usarão botões no seu desenvolvimento.

\subsection{Registrador de deslocamento (Shift Register)}
\label{shift}
Registadores de deslocamento são muito utilizados na conversão entre interfaces seriais para interfaces paralelas. A Figura \ref{shift1} mostra um resumo do funcionamento de um registrador de deslocamento. 

\begin{figure}[H]
		\centering
	\includegraphics[width=0.8\textwidth]{figs/shift1.jpg}
	\caption{Esquema resumido: Série para Paralelo com um registrador de deslocamento.}
	\label{shift1}
	\source{Adaptado de http://electriciantraining.tpub.com/14185/css/Serial-And-Parallel-Transfers-And-Conversion-Continued-151.htm}
\end{figure}

Cada bit que chega no registrador de deslocamento é escrito nas portas paralelas seguencialmente. 

Tal comportamento é realizado por meio de uma cascata de \textit{flip-flops}. Um flip-flop é um dispositivo que armazena ou reseta um bit de acordo com sinais nas suas portas. 

A figura \ref{shift2} mostra a estrutura interna de um registrador de deslocamento com mais detalhes. Cada vez que um salto alto é posto no pino de Clock, um novo bit que entra no pino \textit{Data in} e os que estavam armazenados nos \textit{flip-flops} são levados para os flip-flops da frente.

Os pinos Q1, Q2, Q3,...,QN são os pinos a serem utilizados para leitura paralela. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/shift2.png}
	\caption{Cascata de \textit{flip-flops} num registrador de deslocamento.}
	\label{shift2}
\end{figure}

Uma arquitetura similar pode ser usada para realizar a conversão entre comunicação paralela para serial.

Registradores de deslocamento são muito utilizada para controlar diversas entradas e saídas para além das entradas e saídas disponibilizadas por um microcontrolador. 

Geralmente, os registradores de deslocamento tratam apenas de valores digitais($V_{cc} ou GND$) em seus pinos.

Para os propósitos deste trabalho, será usado o registrador de deslocamento 74HC595 \cite{DATASHEET3}. A Figura \ref{shift3} mostra a pinagem desse circuito integrado:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/shift3.jpg}
	\caption{Pinagem Registrador de Deslocamento 74HC595.}
	\label{shift3}
\end{figure}

A descrição dos pinos é a seguinte:

\begin{itemize}
	\item\textbf{Pino 14}: Pino para entrada de dados seriais.
	\item \textbf{Pino 16}: Pino de alimentação VCC.
	\item \textbf{Pino 8}: Pino de referência GND.
	\item\textbf{Pinos 1 a 7 e 15 (Q1 a Q7 e Q0)}:
	\item \textbf{Pino 10:} O pino 10 é chamado de \textit{Master Reset (MR)}. Quando um valor baixo de tensão é identificado nesse pino, o registrador de deslocamento é resetado e todos dados que ainda estiverem nele são perdidos.
	\item \textbf{Pino 11}: O pino 11 é destinado para o sinal do clock do sistema, que determinará qual será a frequência com que os bits são deslocados pelo registrador.
	\item \textbf{Pino 12}: O pino 12 é o \textit{Latch Pin}. Quando este pino está no estado de LOW, o registrador de deslocamento está pronto para receber dados na sua pino de entrada. Quando este pino está no estado de HIGH, o registrador de deslocamento é configurado para escrever os dados lidos no pinos Q1 a Q7 e Q0.
	\item \textbf{Pino 13}: O pino 13 é o pino responsável por permitir ou bloquear a transmissão dos dados para as portas de saída. Quando o pino está no estado LOW (GND), a transmissão está permitida, quando está em estado HIGH, a transmissão está bloqueada.
	 
\end{itemize}


Os bits que entram no pino 14 de forma serial e saem, como dito, sequencialmente nos pinos Q0, Q1, Q2, Q3, Q4, Q5, Q6 e Q7. 



\subsection{Sensor de Temperatura - LM35}
\label{sensorTemperatura}

Sensores de temperatura são dispositivos os quais possuem alguma propriedade mensurável alterada pela alteração de temperatura.

Sensores são extremamente importantes para sistemas de automação, em qualquer escala ou ambiente.

Em industrias, onde há processos de produção automatizados, temos muitos tipos de sensores medindo as mais diversas variáveis do processo: temperatura, pressão, peso, pH, dentre muitos outros. Devido a importância da leitura dessas variáveis, existe uma área responsável por instrumentos de medição, a Instrumentação Industrial.

Em ambientes comerciais, sensores de temperatura são muito utilizados para controle de ar-condicionados e verificação de incêndios. Sensores de presença são importantes para segurança. 

Com relação a sensores de temperatura, um dos mais usados e baratos é o sensor LM35. O sensor LM35 possui as seguintes características:

\begin{itemize}
	\item Entrada temperatura, saída Tensão elétrica: Alguns sensores de temperatura são sensores resistivos. Se esse fosse o caso, seria necessário a construção de um tipo de divisor de tensão (seção - \ref{EmbassamentoHardware_DivisorTesao}) para tratar com os dados do sensor na forma de tensão de forma a ter uma variável processável pela placa Galileo.
	\item Sem necessidade de calibração da escala Kelvin para Celsious: Muitas vezes, os sensores possuem respostas calibradas para a escala Kelvin, mas o LM35 já é calibrado para Celsious. \textbf{A sensibilidade do LM35 é 10mV/$^{\circ}$C}
	\item O LM35 consome apenas 60  uA na faixa de 4 a 20 V de alimentação, portanto, pouca influência na leitura ocorre por auto-aquecimento\cite{DATASHEET4}.
\end{itemize} 	

A Figura \ref{lm35_0} mostra o LM35 e a Figura \ref{lm35_2} mostra sua pinagem.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figs/lm35.jpg}
	\caption{Sensor de Temperatura LM35.}
	\label{lm35_0}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figs/lm35_2.jpg}
	\caption{Pinagem LM35.}
	\label{lm35_2}
\end{figure}

Na Figura \ref{lm35_2}, os pinos indicam o seguinte:

\begin{itemize}
	\item \textbf{+Vs}: Pino de alimentação. Para aplicações com a placa Galileo, a alimentação 5V já é adequada.
	\item \textbf{GND}: Pino para se conectado ao terra.
	\item \textbf{Vout}: Pino de saída da leitura realizada.
\end{itemize}

A Figura \ref{lm35_3} mostra a forma adequada de se conectar o LM35 à placa Galileo.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/lm35_3.jpg}
	\caption{Circuito sensor de temperatura feito com LM35 e com a placa Galileo.}
	\label{lm35_3}
\end{figure}

Nesse circuito, a temperatura é lida no pino analógico A0.

\subsection{Capacitores}
\label{capac}
Capacitores, ao contrário dos resistores que apenas dissipam energia, são dispositivos ativos num circuito elétrico, ou seja, eles armazenam energia. Tal armazenagem é realizada pelo mantimento de cargas elétricas num campo elétrico.

Tipicamente, os capacitores consistem em dois eletrodos ou placas que armazenam cargas de polaridades opostas e um dielétrico isolando tais placas. A Figura \ref{cap1} mostra a estrutura de um capacitor formados por duas placas.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/capacitor1.jpg}
	\caption{Estrutura básica de um capacitor}
	\label{cap1}
\end{figure}

Para calcular a capacitância de um capacitor semelhante ao da Figura \ref{cap1}, usa-se a seguinte expressão:

\begin{equation}\label{eqCap1}
C = \epsilon_{o}\epsilon_{r}\frac{A}{d}
\end{equation}

Onde C é a capacitância dada em \textit{Farad}, $\epsilon_{o}$ é a permissividade eletrostática do meio e $\epsilon_{r}$ é a constante dielétrica do isolante.

A Figura \ref{cap2} mostra um circuito com uma fonte de tensão, um resistor e um capacitor. A placa do capacitor mais próxima do potencial elétrico mais elevado, será  carregada com cargas positivas e a outra placa será carregada com cargas negativas.

A tensão entre os terminais do capacitor é dada pela seguinte expressão:

\begin{equation}\label{eqCap2}
V = \frac{q}{C} 
\end{equation}

Onde q é a carga acumulada entre os terminais e C é a capacitância do capacitor.

A energia elétrica acumulada num capacitor é dada pela seguinte expressão:

\begin{equation}\label{eqCap3}
U = \frac{1}{2} CV^2 
\end{equation}

Onde U é a energia acumulada, C é a capacitância e V é a tensão entre os terminais do capacitor.

Capacitores são comumente usados em fontes de energia onde elas suavizam a saída de uma onda retificada completa ou meia onda.

As aplicação dos capacitores para transmissão de energia elétrica são comumente relacionadas a correção de fator de potência. Fator de potência é um indicador do quando da energia produzida é efetivamente transmitida. Também podem ser usados em circuitos como filtro passa-baixa, passa-alta ou passa-banda, dependendo da configuração. 

Neste trabalho, será explicado o filtro passa-baixa o qual tem aplicações diretas de processamento de sinais para circuitos como os utilizados em micro-controladores como a placa Galileo.



\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/capacitor3.jpg}
	\caption{Circuito com um capacitor}
	\label{cap2}
\end{figure}


\subsection{Filtro RC}
\label{filtroRC}

Um circuito formato com um resistor e um capacitor (filtro RC) é um dos mais simples filtros de sinais elétricos.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/capacitor4.jpg}
	\caption{Filtro RC.}
	\label{cap4}
\end{figure}

Utilizando a fórmula da tensão entre os terminais de um capacitor (equação \ref{eqCap2} ) e a lei das tensões numa malha fechada (equação \ref{eqKirchoof2}) para o circuito mostrado da Figura \ref{cap4}, tem -se a seguinte expressão:

\begin{equation}\label{eqCap5}
V_{s} - V_{R} -  V_{C} = 0
\end{equation}

\begin{equation}\label{eqCap6}
V_{s} = \frac{q}{C} + I*R
\end{equation}

Muitas vezes, a fórmula da tensão elétrica  apresentada na equação essa mesma expressão é tomada em função da corrente elétrica. Daí, tem-se a seguinte expressão

\begin{equation}\label{eqCap7}
V_{s} = \frac{\int I dt}{C} + I*R
\end{equation}

Tomando-se a derivada da equação \ref{eqCap7}, assumindo que $V_{s}$ é uma tensão constante, tem-se:


\begin{equation}\label{eqCap71}
 0 =  \frac{I}{C} +  \frac{dI}{dt}*R
\end{equation}

A solução dessa equação para a tensão sobre o capacitor, assumindo condições iniciais de tensão e corrente nulas, é a seguinte:

\begin{equation}\label{eqCap8}
V_{c} = V_{s}(1 - e^{\frac{t}{RC}})
\end{equation}

O gráfico mostrado na Figura \ref{cap7} mostra a evolução da tensão sobre o capacitor e sobre o resistor num circuito RC. A constante $\tau$ é igual a RC.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/capacitor7.jpg}
	\caption{Evolução da tensão no capacitor e no resistor no tempo, num circuito RC.}
	\label{cap7}
\end{figure}


A exp \textit{RC} da equação \ref{eqCap8} indica quanto tempo o capacitor leva para carregar 69 por cento do seu valor final. Quando o tempo tende para o infinito, o capacitor num circuito RC tende a se comportar como um circuito aberto. A tensão sobre o capacitor tende a tensão de alimentação e a corrente tende a zero, ou seja, 

\begin{equation}\label{eqCap9}
\lim_{t\to\infty} V_{c} = V_{s}
\end{equation}


Com relação a sinais AC, circuitos RC são muito utilizados como filtros passa-baixa, como mostrado no diagrama de bode da Figura \ref{cap5}. Para frequências acima da frequência de corte $ \frac{1}{2 \pi RC}$ a amplitude do sinal é atenuada. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/capacitor5.jpg}
	\caption{Diagrama de bode de um filtro RC.}
	\label{cap5}
\end{figure}

Para os propósitos deste trabalho, o filtro RC será utilizado para atenuar ruídos de alta frequência e realização a estabilização de sinais enviados à placa Galileo por meio de interruptores.

\subsection{Inversor Schmitt trigger}
\label{inversor}

Um inversor é um circuito comparador com histerese com feedback na entrada positiva de um comparador ou um amplificado operacional. Define-se histerese como um comportamento relativo a variável de saída que é distinto nos caminho de aumento da variável de entrada e subsequente diminuição desta.

A Figura \ref{histerese} mostra um sinal com histerese. Tendo a variável de entrada \textit{in} partindo do valor -T a até o valor T, a variável de saída \textit{out} terá valor -M. Após isso, caso a variável de entrada \textit{in} volte para o valor -T, a variável de saída terá como valor +M.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/histerese.png}
	\caption{Sinal com histerese.}
	\label{histerese}
\end{figure}

Um inversor \textit{Schimtt trigger} pode ser implementado utilizando, como dito, feedback na entrada positiva de um amplificado operacional como mostrado na Figura \ref{histerese2}.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/histerese2.png}
	\caption{Implementação de um inversor com histerese com amplificador operacional e diodos zener.}
	\label{histerese2}
	\source{Adaptado de Alessio Damato - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1178935}
\end{figure}


O circuito mostrado na Figura  \ref{histerese2} é um comparador implementado com um amplificador operacional. A saída do amplificador $V_{out}$ obedece às seguintes expressões


\begin{equation}\label{eqinversor1}
V_{out} = +V_{z}, quando V_{+} > V_{-}
\end{equation}

e


\begin{equation}\label{eqinversor2}
V_{out} = -V_{z}, quando V_{+} < V_{-}
\end{equation}

$V_{z}$ é a tensão de quebra dos diodos zeners, conectados na saída do amplificador operacional. 

As tensões de ida e volta de histerese para esse circuito são encontradas seguindo a seguinte expressão:

\begin{equation}\label{eqinversor3}
V_{+} = V_{in} . \frac{R2}{R1 + R2} + V_{out}\frac{R1}{R1 + R2} 
\end{equation}

A expressão da equação \ref{eqinversor3} é obtida utilizando a segunda lei de Kirchoff (equação \ref{eqKirchoof2}) e o teorema da superposição.

Os pontos de quebra +M e -M são obtidas da equação \ref{eqinversor3} quando $V_{+}$ é igual a $V_{-}$, ou seja:


\begin{equation}\label{eqinversor4}
+T = V_{in} = V_{-} . (1 + \frac{R1}{R2}) - V_{out} . \frac{R1}{R2}
\end{equation}

e


\begin{equation}\label{eqinversor5}
-T = - V_{in} = - V_{-} . (1 + \frac{R1}{R2}) + V_{out} . \frac{R1}{R2}
\end{equation}

Caso a tensão $V_{-}$ seja igual a zero, tem-se:

\begin{equation}\label{eqinversor6}
T = V_{in} . \frac{R1}{R2}
\end{equation}

e


\begin{equation}\label{eqinversor7}
-T = V_{in} . \frac{R1}{R2}
\end{equation}

As expressão \ref{eqinversor3}, \ref{eqinversor4} e \ref{eqinversor5} são validas para o caso de $V_{-} = 0$. Caso $V_{-}$ seja diferente de zero, o gráfico mostrado na Figura \ref{histerese} será deslocado para direita ou esquerda a depender do valor de $V_{-}$ e resistores $R1 e R2$ como indicado pelas equações \ref{eqinversor3} e \ref{eqinversor4}.  

Em resumo, a saída de tensão do Schmitt trigger mostrado na Figura \ref{histerese2} se resumirá apenas aos valores $+V_{z} e - V_{z} $ independentemente de ruídos na entrada.


O inversor Schmitt trigger a ser usado nas práticas propostas neste trabalho é o 74HC14 \cite{DATASHEET5}.

A Figura \ref{inversor2} mostra os pinos do chip 74HC14. No 74HC14, 6 inputs distintos podem ser invertidos usando os pinos de 1 a 12.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/inversor2.jpg}
	\caption{Inversor Schmitt trigger 74HC14 \cite{DATASHEET5} - pinos.}
	\label{inversor2}
\end{figure}

A Figura \ref{inversor1} mostra digramas lógicos do chip 74HC14. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/inversor1.jpg}
	\caption{Inversor Schmitt trigger 74HC14 \cite{DATASHEET5} - diagramas lógicos.}
	\label{inversor1}
\end{figure}

A Figura \ref{inversor3} mostra parâmetros eletrônicos e a curva de histerese do chip 74HC14. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figs/inversor3.jpg}
	\caption{Inversor Schmitt trigger 74HC14 \cite{DATASHEET5} - parâmetros eletrônicos e curva de histerese.}
	\label{inversor3}
\end{figure}


	
\subsection{Debouncing - estabilização de sinais de interruptores}
\label{debounce}
Um dos grandes problemas ao se trabalhar com interruptores ligados a interrupções de hardware é o fenômeno do \textit{bouncing}. \textit{Bouncing} é uma oscilação num sinal de um botão no momento que a tecla é apertada ou solta. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/bouncing1.jpg}
	\caption{Fenômeno de \textit{bouncing} de um sinal de um interruptor.}
	\label{boun1}
\end{figure}



A Figura \ref{boun1} mostra um exemplo do fenômeno do \textit{bouncing}. Quando uma pessoa fecha um interruptor, o sinal deveria, quase instantaneamente, ir para o valor alto, entretanto, o sinal vai e volta aos nível baixo e alto até se estabilizar. 

O mesmo fenômeno se repete quando o interruptor é aberto. O sinal vai e volta aos níveis alto e baixo até eventualmente se estabilizar.

O fenômeno do \textit{bouncing} associado a interruptores causa problemas nas leituras de interrupções de hardware. Tomando a Figura \ref{boun2} como exemplo, não apenas uma interrupção de rampa de subida (seção \ref{intHard}) será identifica pelo micro-controlador, mas 5.

Ao se identificar mais de uma rampa de subida, a rotina associada à tal interrupção será executada mais de uma vez. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/bouncing2.jpg}
	\caption{Interrupções de rampa de subida causadas pelo fenômeno do \textit{bouncing}.}
	\label{boun2}
\end{figure}

Para evitar o fenômeno do \textit{bouncing}, deve-se utilizar um filtro RC (seção \ref{filtroRC}) associado a um inversor Schmitt trigeer (seção \ref{inversor}). 


O esquemático do circuito de deboucing é mostrado na Figura \ref{boun3}.  

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/debounce1.jpg}
	\caption{Circuito para \textit{debouncing} de um sinal de um interruptor.}
	\label{boun3}
\end{figure}

A tensão de saída é o inversor da tensão lida no capacitor $V_{c}$, obedecendo a curva de histerese do Schmitt trigger mostrada na Figura \ref{inversor3}. Com o botão aberto, a tensão sobre o capacitor será 5 V, e a tensão de saída $V_{out}$ será 0V ou 0 lógico

Quando a chave é fechada, o capacitor começa a descarregar. No final desse processo, a tensão sobre o capacitor será próxima a 0V e a tensão de saída será 5V ou lógico 1.

A Figura \ref{boun4} mostra o resultado do uso do circuito de debounce. Aparte qualquer \textit{bouncing} que ocorrer no sinal do interruptor, o uso do capacitor suavizará tais efeitos e o uso do inversor adequará os níveis lógicos do sinal de saída para a leitura de interrupçõescom apenas uma rampa de subida ou descida como sinal do interruptor.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/debounce2.jpg}
	\caption{Resultado do uso do circuito de \textit{debouncing} de um sinal de um interruptor.}
	\label{boun4}
	\source{http://www.carlitoscontraptions.com/2007/03/switch-debouncer/}
\end{figure}

Uma escolha adequada para os valores do capacitor e resistor são respectivamente 10kohm e 10 uF. Com essa escolha a constante RC tem como valor 0.1 segundos para. Tem valor é mais que adequada ao tempo de resposta humana.
\subsection{Matriz de Leds}
\label{matrizLeds}

Muitas vezes, se deseja trabalhar com um conjunto de leds dispostos na formato de uma matriz como mostrado na Figura \ref{matrix1}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth]{figs/matrix1.jpg}
	\caption{Estrutura esquemática de uma matriz de leds 8x8.}
	\label{matrix1}
\end{figure}

Para acender um LED em específico na estrutura da matriz de leds, deve-se setar uma das linhas com valor alto de tensão (valor lógico 1) e uma das colunas com valor baixo de tensão (valor lógico 0). 

Caso se queria, por exemplo, acender o led localizado na linha 7 e coluna 2, deve-se colocar na trilha da linha 7 5 Volts (valor lógico 1).

Ao se setar linha ou coluna ao certo estado (0 ou 1 lógico), toda a linha ou coluna fica comprometida a esse estado, daí, não será possível acender uma linha e uma coluna ao mesmo tempo. 

Para poder acender uma linha e uma coluna, deve-se multiplexar tais estados, ou seja, acender e apagar, alternadamente, linhas e colunas rapidamente, de forma que a visão humana seja incapaz de perceber tal alternação de estados.

\subsection{Driver de matriz de led}
\label{driver}

Uma matriz de leds NxN (seção \ref{matrizLeds}) pode ser controlado utilizando 2N portas digitais. Por exemplo, se for usada uma matriz de led 8X8 serão necessárias 16 portas digitais para controlar tal matriz. 

Caso fosse usada uma matriz 16X16, seriam necessários 32 portas digitais para controle de tal matriz. Não há placa que seja capaz de oferecer tal quantidade de portas. 

Para possibilitar o controle de tantos led sem utilizar tantas portas digitais, é necessário utilizar um circuito integrado que, como o chip 74HC595 (seção \ref{shift}), transforme comunicação serial em comunicação paralela. 

Para realizar o propósito de controlar uma matriz de leds usando poucas portas digitais, deve-se usar um \textit{driver de display}. 

Neste trabalho, será usado o circuito integrado MAX7219 como \textit{driver de display}. A Figura  \ref{driverLed0} mostra os pinos do MAX7219.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/driverLed0.jpg}
	\caption{Pinos do circuito integrado MAX7219.}
	\label{driverLed0}
\end{figure}

A conexão dos pinos é a seguinte:

\begin{itemize}
	\item Pinos 2, 11, 6, 7, 3, 10, 5 e 8 : DIG0, DIG1, DIG2, DIG3, DIG4, DIG5, DIG6 respectivamente.
	\item Pinos 14, 16, 20, 23, 21 e 15: SEG A, SEG B, SEG C, SEG D, SEG E e SEG F respectivamente.
	\item Pino 1 (Din): Pino digital 12 da placa Galileo.
	\item Pino 13 (Clk): Pino digital 11 da placa Galileo.
	\item Pino 12 (LOAD(cs)): Pino digital 10 da placa Galileo.
	\item Pinos 4 e 9: Pino GND
	\item Pinos 18 e 19: Pino 5V
\end{itemize}

A Figura \ref{driverLed2} mostra um esquemático de tais conexões realizadas.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/driverLed2.jpg}
	\caption{Conexão dos pinos do MAX7219 à placa Galileo.}
	\label{driverLed2}
\end{figure}

O circuito da Figura \ref{driverLed1} mostra um circuito integrado com a maioria das conexões mostradas na Figura \ref{driverLed2} já feitas exceto os pinos Vcc, GND, Din, CS, e CLK. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth]{figs/driverLed1.jpg}
	\caption{Placa matriz 8x8 + MAX7219.}
	\label{driverLed1}
\end{figure}

A seção

	 
\section{Software}
\label{EmbassamentoSoftware}

Nesta seção são tratados todos conceitos relativos a programação que embasam as práticas propostas na seção \ref{CapExperimentos}.

\subsection{Programação estruturada}
\label{EmbassamentoSoftware_ProgramaçãoEstruturada}

Programação estruturada é um paradigma de programação cujo objetivo é claridade do código, qualidade e tempo de desenvolvimento de software e tempo de execução de algoritmo. 

Para alcançar tais objetivos, linguagens de programação que se baseiam no paradigma de programação estruturada possuem as seguintes características:

\begin{itemize}
	\item \textbf{Sequência} bem definida de passos a serem seguidos utilizando:
		\subitem Condicionais
		\subitem Loops
		\subitem Chamadas a funções iterativas e recursivas
	\item \textbf{Modularização} do código, em:
		\subitem Funções.
		\subitem Estruturas de dados.
		\subitem Uso de bibliotecas.
\end{itemize}

Para se resolver um determinado problema sob o paradigma de programação estruturada, deve-se subdividir tal problema em problemas menores.

A solução final é a junção sequencial e lógica dos problemas menores. 

A subdivisão proposta pelo paradigma estruturado oferece as seguintes vantagens:

\begin{itemize}
	\item Cada parte menor tem um código mais simples
	\item Facilidade de entendimento do código, uma vez que os subprogramas podem ser analisados como partes independentes (legibilidade)
	\item Códigos menores são mais facilmente modificáveis para satisfazer novos requisitos do usuário e para correção de erros (manutenibilidade)
	\item Simplificação da documentação de sistemas
	\item Desenvolvimento de software por equipes de programadore 
	\item Reutilização de subprogramas através de bibliotecas de subprogramas, na linguagem C, sob a forma dos arquivos de cabeçalhos (.h)
\end{itemize}



\subsection{Programação para Arduino}
\label{EmbassamentoSoftware_Arduino}
Nesta sub-seção são explicados os conceitos relevantes para as práticas propostas na seção \ref{CapDesenvolvimento}.

\subsubsection{Padrão de programação em Arduíno}
\label{EmbassamentoSoftware_Arduino_Padrao}
Todo programa escrito para Arduíno deve ter, obrigatoriamente, duas funções: função \textbf{setup} e a função \textbf{loop}.

A função setup é a primeira a ser executada pela plataforma programada em Arduino. Em geral, essa função serve para realizar configurações e definições iniciais.

A função loop é executa após a setup ser executada. A função loop será repetida indenfinidamente, até a placa Galileo ser desligada ou o botão \textit{reset} ser apertado. Caso o botão reset seja apertado, a execução do programa volta a seu inicío.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{figs/Arduino13.jpeg}
	\caption{Fluxograma de um programa escrito para Arduino.}
	\label{Arduino13}
\end{figure}

O fluxo comum de um programa escrito para Arduino é mostra na Figura \ref{Arduino13}. Quanto ao botão reset, a Figura \ref{Arduino13} é simplificada. O botão reset pode ser apetado a qualquer momento. Ao ser apertado, o botão, é ativado uma \textit{interrupção de hardware} a qual faz com que a execução do programa volte ao ínicio.  

\subsection{Uso de portas digitais}
\label{EmbassamentoSoftware_Arduino_UsoPortasDigitais}
Diz-se por porta digital, um pino, de entrada ou saída de tensão, que por ele podem ser lidos ou escritos apenas 0 ou 1 lógicos.

Para uma placa Galileo, 0 lógico é identificado como 0 Volts(GND) e 1 lógico é identificado como 3.3 ou 5 Volts entrando ou saindo da porta digital selecionada. 

Seleciona-se 3.3 ou 5 Volts como valor de referência de tensão com o pino \textit{\textbf{IOREF}}. 

Deve-se tomar cuidado ao utilizar uma porta digital como entrada(\textit{input}). Caso a tensão aplicada à porta for maior que a tensão selecionada em \textit\textbf{{IOREF}}, pode-se inutilizar a porta.

Para se utilizar uma porta digital, deve-se seleciona-lá na função setup. No código mostrado em \ref{EmbassamentoSoftware_prog1}, mostra-se a seleção da porta digital 13 como saída (OUTPUT) de tensão.

\begin{lstlisting}[ caption = Selecionando a porta digital 13 para saída de tensão, label=EmbassamentoSoftware_prog1,]

void setup() {
// Seleciona a porta digital 13 como saida de tensao
pinMode(13, OUTPUT);

}
\end{lstlisting}

Para selecionar uma porta digital como porta de entrada de tensão, deve-se usar o comando \textit{pinMode(NumeroPorta, INPUT);}. 

O exemplo a seguir, código \ref{EmbassamentoSoftware_prog2} mostra a porta digital 13 sendo selecionada para entrada de tensão: 

\begin{lstlisting}[ caption = Selecionando a porta digital 13 para entrada de tensão, label=EmbassamentoSoftware_prog2,]

void setup() {
// Seleciona a porta digital 13 como entrada de tensao
pinMode(13, INPUT);

}
\end{lstlisting}

Com relação a porta digital 13, deve-ser apontado que nela já está conectado, automaticamente, um resistor de 13kOhms. Dessa forma, por nela pode ser diretamente ligado um LED, sem correr o risco de queimá-lo.

\subsection{Processo de Compilação}
\label{EmbassamentoSoftware_Compilacao}

Todo programa de computador, escrito em passa de uma tradução de uma linguagem compreensível por um ser humano para uma linguagem compreensível para um sistema computacional, ou seja, uma série de bits.

A Figura \ref{compilacao1} mostra os passos realizados nesse processo. Para fins deste trabalho e desta seção será focado apenas nos passos pré-compilação e nos passos de análise léxica, sintática e semântica de um código. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.2\textwidth]{figs/compilador1.png}
	\caption{Fluxograma de um programa escrito para Arduino.}
	\label{compilacao1}
\end{figure}

As etapas a serem tratadas nesta seção são, portanto, os seguintes, como mostrado na Figura \ref{compilacao2} :

\begin{enumerate}
	\item Pré-processamento
	\item Análise Léxica
	\item Análise Sintática 
	\item Análise Semântica
\end{enumerate}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/compilador3.jpg}
	\caption{Etapas de interesse para a disciplina \textit{Algoritmos e Programação de computadores}}
	\label{compilacao2}
\end{figure}


\subsubsection{Pré-processamento}
\label{preProcessamento}
Na etapa de pré-processamento, as diretivas de compilação são resolvidas como mostrado no exemplo da Figura \ref{compilacao4}. Tudo aquilo que foi definido usando a diretiva \textbf{\#define} é substituído, no texto do código fonte, por aquilo que definido no \#define.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figs/compilador4.jpg}
	\caption{Exemplo do processo de pré-processamento}
	\label{compilacao4}
\end{figure}

Além disso, no pré-processamento são removidos comentários e também substituídos no código fonte as macros definidas, como mostrado na Figura \ref{compilacao5}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figs/compilador5.jpg}
	\caption{Exemplo de substituição de macro no pré-processamento.}
	\label{compilacao5}
\end{figure}



\subsubsection{Análise Léxica}

Após a fase de pré-processamento, o compilador realiza a análise léxica do código fonte. 

A análise léxica é feita por módulo chamado \textit{analisador léxico} ou scanner. Nessa fase, o programa é lido da esquerda para a direita agrupando so caracteres de maneira a forma \textit{tokens}. Os tokens são sequências de caracteres que em conjunto possuem um significado, como palavras numa linguagem humana. 

Na análise léxica, cada \textit{token} identificado é analisado de acordo com as regras da linguagem de programação. Na linguagem de programação C, não é permitido a nenhum token ser iniciado com um número e tão pouco podem os tokens possuir caracteres especiais como \$ , \%, \#, etc. 

\subsubsection{Análise Sintática}

Após a análise léxica, onde os tokens identificados são validados, é realizada a análise sintática do código fonte.

A análise sintática resume-se na análise das expressões construídas com os tokens. Um exemplo de erro sintático é mostrado no código \ref{analiseSintatica1}. Nesse exemplo é mostrado o uso do operador $+$ feito incorretamente.

\begin{lstlisting}[ caption = Erro sintático no uso do operador +, label=analiseSintatica1,]
int numero;

numero = 1 + ; //erro sintatico, o operador + espera dois termos, mas o segundo
              // nao explicitado
\end{lstlisting}

\subsubsection{Análise Semântica}

Após a análise léxica, é feita a análise semântica. A análise semântica pode ser resumida como a "analíse do relacionamento entre todas as partes do código". O exemplo  mostra erros semânticos de referência indefinidas no código.    



\begin{lstlisting}[ caption = Erro referência indefinida, label=analiseSemantica1,]
void setup()
{
int a = funcao1(); // erro semantico, refencia indefinida a funcao1()
   
}

void loop()
{ 
int num;

num = num + k; //erro semantico, referencia indefinida a k
}

\end{lstlisting}


\subsection{Diretivas de Compilação}
\label{EmbassamentoSoftware_DireitivasCompilacao}

Como mencionado na seção \ref{EmbassamentoSoftware_Compilacao}, o processo de compilação é iniciado pelo pré-processamento. No pré-processamento, as diretivas de compilação são resolvidas.

As diretivas de compilação mais comuns são  \# include, \# define, \# ifdef, \# else e \# endif .

\begin{itemize}
	
	\item \textbf{\#include}: A diretiva \#include é utilizada para adicionar códigos fontes externos ao código fonte no qual se está trabalhando. As formas de uso da diretiva são as seguintes:
		\subitem \#include <bibliotecaDoSistema.h> : Nessa forma se adiciona uma biblioteca já nativa do sistema, como por exemplo a stdlib.h. A inclusão de tal biblioteca se daria pelo seguinte comando \#include <stdlib.h>
		
		\subitem \#include "bibliotecaDoDesenvolvedor.h" : Nessa forma se adiciona uma biblioteca já desenvolvida pelo programador ou equipe relacionada. Caso o arquivo não se encontre na mesma pasta que o programa que o está adicionando, deve ser fornecido o caminho para ele no include. Por exemplo:
		\#include "/pasta1/pasta2/bibliotecaDoDesenvolvedor.h"
	\item \textbf{\# define}: A diretiva \# define é usada para informar ao compilador quais token serão substituidos por determinadas expressões no processo de pré-processamento, como mostrado na seção \ref{preProcessamento} ou para criar tokens com o status de \textbf{defined} que influenciaram a definição de diretivas posteriores.
	
	\item \textbf{\# ifdef, \# else e \#endif}: A diretivas \# ifdef, \# else e \#endif são usadas em conjunto para realizar definições de diretivas e macros condicionalmente. Um exemplo disso é mostrado no código \ref{diretivas1}, onde o valor da diretiva \textit{constante} é definida de acordo a com definição da diretiva \textit{teste}.    	
\end{itemize}

Um uso muito comum do padrão de diretivas mostrados no código \ref{diretivas1}, é mostrado no código \ref{diretivas2}. Na primeira vez que o compilador ver o arquivo de cabeçalho \textbf{bibliotecaExemplo.h}, a diretiva  \textbf{BIBLIOTECAEXEMPLO} será definida e as funções definidas nesse arquivo passaram a ser reconhecidas pelo compilador. Após essa definição e reconhecimento de funções, não haverá mais erros de redefinição de funções (erro semântico), pois as diretivas \# ifdef  BIBLIOTECAEXEMPLO \# define BIBLIOTECAEXEMPLO  impedirão isso.


\begin{lstlisting}[ caption = Uso de diretivas condicionais, label=diretivas1,]
#define teste  // define a token teste

#ifdef teste // executa a acao dfinida dentro deste #ifdef, pois teste estah //definido
	#define constante 3 // define diretiva constante com o valor 3
#else  // nao entra nesta secao pois teste estah definifo
	#define constante 4 // // define diretiva constante com o valor 4
#endif     
\end{lstlisting}

\begin{lstlisting}[ caption = Uso de diretivas para evitar erro de compilação de repetição de inclução de arquivos, label=diretivas2,]

#ifdef  BIBLIOTECAEXEMPLO
#define BIBLIOTECAEXEMPLO  // define a token teste

void funcao1()
{
}

void funcao2()
{
}

.
.
.
void funcaoN()
{
}

#endif     
\end{lstlisting}

\subsection{Tipos básicos de variáveis}
\label{EmbassamentoSoftware_TiposVariaveis}

Variáveis são os elementos básicos que um programa manipula. Uma variável é um espaço reservado na memória do computador para armazenar um tipo de dado determinado. Variáveis devem receber nomes para poderem ser referenciadas e modificadas quando necessário. Muitas linguagens de programação exigem que os programas contenham declarações que especifiquem de que tipo são as variáveis que ele utilizará e as vezes um valor inicial. Tipos podem ser por exemplo: inteiros, reais, caracteres, etc. As expressões combinam variáveis e constantes para calcular novos valores. 

Os tipos básicos de variáveis são os seguintes:

\begin{itemize}

\item char: Caracter: O valor armazenado é um caractere. Caracateres geralmente são armazenados em códigos (usualmente o código ASCII).
\item int: Número inteiro é o tipo padrão e o tamanho do conjunto que pode ser representado normalmente depende da máquina em que o programa está rodando.
\item float: Número em ponto flutuante de precisão simples. São conhecidos normalmente como números reais.
\item double: Número em ponto flutuante de precisão dupla
\item void: Este tipo serve para indicar que um resultado não tem um tipo definido. Uma das aplicações deste tipo em C é criar um tipo vazio que pode posteriormente ser modificado para um dos tipos anteriores.

\end{itemize}

Cada um desses tipos é codificado diferentemente para cada arquitetura computacional para a qual o programa será compilado. A tabela \ref{tabVariaveis1} mostra o uso de espaço de memória normalmente empregado nas arquiteturas computacionais.

\begin{table}[H]
	\centering
	\caption{Tamanho e faixa de uso para os tipos básicos váriaveis}
	\label{tabVariaveis1}
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Tipo}   & \textbf{Tamanho em Bytes} & \textbf{Faixa Mínima}          \\ \hline
		\textbf{char}   & 1                         & -127 a 127                     \\ \hline
		\textbf{int}    & 4                         & -2.147.483.648 a 2.147.483.647 \\ \hline
		\textbf{float}  & 4                         & Seis digitos de precisão       \\ \hline
		\textbf{double} & 8                         & Dez digitos de precisão        \\ \hline
	\end{tabular}
\end{table}

Muitas vezes, as faixas para os tipos de variáveis mostradas na tabela \ref{tabVariaveis1} não são suficientes ou adequadas para o algoritmo emd desenvolvimento. Para resolver tais problemas, podem ser utilizados \textit{modificadores} para ampliar, reduzir ou adequar a faixa de valores que a variável pode guardar no endereço de memória reservado.

Os modificadores de variáveis e seus respectivos efeitos sobre a faixa de valores de cada tipo são mostrado na tabela 

\begin{table}[H]
	\centering
	\caption{Todos os Tipos de dados definidos pelo Padrão ANSI C, seus tamanhos em bytes e suas faixa de valores.}
	\label{tabVariaveis2}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{figs/tabVariaveis2.jpg}
		\caption*{}
		\label*{}
	\end{figure}
	
\end{table}


\subsection{Conversão entre tipos de variáveis}
\label{EmbassamentoSoftware_ConversaoEntreVariaveis}

Conforme explicado na seções anteriores, variáveis vêm em diferentes tipos. O tipo determina o tipo de dados que uma variável pode conter. Uma variável Integer pode conter somente dados numéricos sem pontos decimais. Uma variável char pode conter somente uma letra ou símbolo contido na tabela ASCII.


Muitas vezes, faz-se necessário ou mais conveniente realizar a conversão de um tipo de variável para outro mais conveniente. Para realizar a conversão, deve-se utilizar o comando escrever, ao lado da variável que será convertida a seguinte expressão (NOVOTIPO) variável. O código  \ref{conversao1} mostra duas situações onde uma variável inteira é convertida para um char. 

Na primeira, não se perde informação, pois o conteúdo da variável \textit{num} pode ser expresso em 1 byte. Na segunda situação, no entanto, se perde informação, pois 10000 (conteúdo da variável num2) não pode ser expresso em 1 byte.

\begin{lstlisting}[ caption = Convertendo int para char, label=conversao1,]
int num = 1;//variavel ocupando 32 bits(4 bytes)

char a = (char)num; // conversao para variavel contendo 8 bits (1 byte)
                    // conversao sem perda de informacao

int num2 = 100000; 

char b = (char) num2; // conversao com perda de informacao
                      // uma variavel char so pode guardar ateh 127
\end{lstlisting}



\subsection{Leitura Analógica - Conversão Analógico/Digital}
\label{EmbassamentoSoftware_ConversaoAnalogicoDigital}

Para ler o sinal de tensão analógico num dos 6 pinos destinados a conversão Analógico/Digital deve ser utilizada a função \textit{analogRead()}. O código \ref{analogRead1} mostra um exemplo da utilização da função \textit{analogRead()}, conversão de int para float, e ajuste de escala. 

A função \textit{analogRead} tem como argumento de entrada o número do pino que será lido. O tempo de leitura é aproximadamente 100 \si\micro s. O retorno dessa função estará entre 0 e 1023, devido ao tamanho do registrador de conversão A/D mencionado na sub-seção \ref{ConversaoAD}.

Para calcular o valor da tensão no pino de entrada na faixa de 0 a 5V é necessário realizar a conversão de variável citada na seção \ref{EmbassamentoSoftware_ConversaoEntreVariaveis}.



\begin{lstlisting}[ caption = Uso da funcao analogRead, label=analogRead1,]
void setup()
{
}

int sensor;
float valorReal
void loop()
{
sensor = analogRead(A0); //  0<= sensor <=1023

ValorReal = (float)(5*sensor)/1023 // conversão de tipo de variável e conversão //   		                          //de escala usando uma regra de 3

}
\end{lstlisting}





\subsection{Estruturas Condicionais}
\label{EmbassamentoSoftware_EstruturasCondicionais}

Chama-se de estrutura condicional as instruções para testar se uma condição é verdadeira ou falsa.

 Para expressar uma condição, deve-se utilizar operadores relacionais e, se necessário operadores lógicos. 
 
 \subsubsection{Operadores Relacionais}
 A tabela \ref{tabCond1} mostra todos operadores relacionais possíveis. É mostrado, na coluna exemplo, que as expressões entre os operadores podem ser quaisquer, desde que não incorreram em erros léxicos, sintáticos ou semânticos.
 
 \begin{table}[H]
 	\centering
 	\caption{Operadores relacionais}
 	\label{tabCond1}
 	\begin{tabular}{|c|c|c|}
 		\hline
 		\textbf{Operador relacional} & \multicolumn{1}{l|}{\textbf{Exemplo de aplicação}} & \textbf{Explicação do exemplo}                                                                 \\ \hline
 		==                           & a == b                                             & verifica se a é igual a b                                                                      \\ \hline
 		!=                           & a != b * 3                                         & \begin{tabular}[c]{@{}c@{}}verifica se a é diferente de b\\ \\ multiplicado por 3\end{tabular} \\ \hline
 		\textgreater                 & a \textgreater (b + a)                             & \begin{tabular}[c]{@{}c@{}}verifica se a é maior do que \\ b + a\end{tabular}                  \\ \hline
 		\textgreater=                & (a - b + 5) \textgreater= (b /2)                   & \begin{tabular}[c]{@{}c@{}}verifica se (a - b + 5) é maior ou \\ igual a b/2\end{tabular}      \\ \hline
 		\textless                    & a \textless b                                      & verifica se a é menor do que b                                                                 \\ \hline
 		\textless=                   & a \textless= b                                     & verifica se a é menor ou igual a b                                                             \\ \hline
 	\end{tabular}
 \end{table}
 
 Toda vez que uma operação lógica é aplicada, é retornado TRUE ou FALSE. Os sistemas computacionais identificam FALSE com o valor zero e TRUE como qualquer valor diferente de zero (inclusive valores negativos).
 
 \subsubsection{Operadores Lógicos}
 Operadores lógicos são usados para combinar 2 ou mais operações relacionais. A tabela  \ref{tabCond2} mostra os operadores lógicos, exemplo e explicação de tais exemplos.
 
 \begin{table}[H]
 	\centering
 	\caption{Operadores \textbf{E}, \textbf{OU} e \textbf{Negação}}
 	\label{tabCond2}
 	\begin{tabular}{|c|c|c|}
 		\hline
 		\textbf{Operador lógico}                                       & \multicolumn{1}{l|}{\textbf{Exemplo de aplicação}} & \textbf{Explicação do exemplo}                                                                                                                                                                                           \\ \hline
 		\begin{tabular}[c]{@{}c@{}}(Operador E)\\ \&\&\end{tabular}    & ((a == b)\&\&( a \textgreater 0))                  & \begin{tabular}[c]{@{}c@{}}verifica se a é igual b \\ E\\ verifica se a é maior que 0\\ se as duas expressões forem verdadeiras,\\ retorna-se TRUE nessa operação lógica\\ do contrário, retorna FALSE\end{tabular}      \\ \hline
 		\begin{tabular}[c]{@{}c@{}}(Operador OU)\\ ||\end{tabular}     & (a \textgreater b )|| ( b \textgreater 3)          & \begin{tabular}[c]{@{}c@{}}verifica se a é maior do que b \\ OU\\ se b é maior que 3\\ se qualquer uma das expressões for verdadeira\\ ,retorna-se TRUE\\ Se a duas expressões forem FALSE,\\ retorna FALSE\end{tabular} \\ \hline
 		\begin{tabular}[c]{@{}c@{}}(Operador negação)\\ !\end{tabular} & !(a \textgreater b)                                & \begin{tabular}[c]{@{}c@{}}verifica se a é maior do que b.\\ Caso isso seja verdadeiro,\\ retorna FALSE\\ Caso a expressão lógica seja falsa,\\ retorna TRUE\end{tabular}                                                 \\ \hline
 	\end{tabular}
 \end{table}
 
 As tabelas verdades das tabelas \ref{tabCond3}, \ref{tabCond4} e \ref{tabCond5} mostram as mesmas relações exemplificadas na tabela \ref{tabCond2}.
 
 \begin{table}[H]
 	\centering
 	\caption{Tabela verdade do operador ||.}
 	\label{tabCond3}
 	\begin{figure}[H]
 		\centering
 		\includegraphics[width=0.6\textwidth]{figs/condicional2.jpg}
 		\caption*{}
 		\label*{}
 	\end{figure}
 	
 \end{table}
 
 
 
 \begin{table}[H]
 	\centering
 	\caption{Tabela verdade do operador \&\& .}
 	\label{tabCond4}
 	\begin{figure}[H]
 		\centering
 		\includegraphics[width=0.6\textwidth]{figs/condicional3.jpg}
 		\caption*{}
 		\label*{}
 	\end{figure}
 	
 \end{table}


\begin{table}[H]
	\centering
	\caption{Tabela verdade do operador ! .}
	\label{tabCond5}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.6\textwidth]{figs/condicional4.jpg}
		\caption*{}
		\label*{}
	\end{figure}
	
\end{table}


\subsubsection{Controle de fluxo de execução de um programa (Condicionais)}

Os operações lógicas construídas juntamente a operadores relacionais são a base para o controle do fluxo com os seguintes operadores:

\begin{itemize}
	\item if
	\item if - else 
	\item if - (else if) - else (if-else aninhados)
	\item switch - case
	\item operador \textbf{?} (ternário)
\end{itemize} 

A Figura \ref{cond5} mostra o resumo do que acontece ao se utilizar qualquer dos operadores de controle de fluxo supracitado. Se certa condição lógica é verdadeira (TRUE) se executa uma série de instruções específicas, senão se executa as intruções específicadas para o caso adverso e então se contínua o fluxo normal do programa.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{figs/condicional5.jpg}
	\caption{Resumo do controle de fluxo de um programa}
	\label{cond5}
\end{figure}

O operador \textbf{if} possui a sintaxe mostrada no código \ref{cond6}. Caso a condição lógica especificada por \textit{condicao1} seja verdadeira, ou seja, caso tal condição retorne verdadeiro (TRUE), os procedimentos dentro das chaves (\{ \}) devem ser executados.  

\begin{lstlisting}[ caption =  Sintaxe do if, label=cond6,]
if(condicao1)//verifica se as condições lógicas especificadas em 
{			//condicao1 sao 
            // verdadeira(TRUE). Caso sejam, executa os 
			//  procedimentos dentro da chave
	condicao1Procedimento1;
	condicao1Procedimento2;
	.
	.	
	.
	condicao1ProcedimentoN;
}.
\end{lstlisting}
O código \ref{cond6_2} mostra um exemplo de uso do if. Supondo que exista uma certa variável chamada \textit{sensor}, caso ela seja maior que 300, a placa Galileo deve escrever na porta digital 2 um valor alto (HIGH) de tensão.

\begin{lstlisting}[ caption =  Exemplo de uso do if, label=cond6_2,]
if(sensor > 300)
{            
  digitalWrite(2,HIGH);
}
\end{lstlisting}


O operador if - else segue o mesmo padrão mostrado nos códigos \ref{cond6} e \ref{cond6_2}.A diferenção, nesse caso, é a adição do else (senão) ao bloco. Caso a condição especificada no if não seja verdadeira, o programa deve executar a série de instruções especificadas dentro do bloco do else. O código \ref{cond7} mostra a sintaxe de uso do bloco if - else e o código \ref{cond7_2} mostra um exemplo de aplicação do bloco if - else.

\begin{lstlisting}[ caption =  Sintaxe do bloco if - else, label=cond7,]
if(condicao1)
{
	condicao1Procedimento1;
	condicao1Procedimento2;
	.
	.			
	.
	condicao1ProcedimentoN;
}.
else// caso a condição especificada por condicao1 seja falsa (FALSE), deve se
{   // executar a série de instruções especificadas dentro do else
	elseCondicao1Procedimento1;
	elseCondicao1Procedimento2;
	.
	.	
	.
	elseCondicao1ProcedimentoM;
}
\end{lstlisting}


\begin{lstlisting}[ caption =  Exemplo de uso do bloco if - else, label=cond7_2,]
if(sensor > 300)
{            
digitalWrite(2,HIGH);
}
else
{
digitalWrite(2,HIGH);
contador = contador + 1;

}
\end{lstlisting}


O bloco if-else pode ser extendido indefinidamente com condições intermediárias entre o if e o else final. Como mostrado no código \ref{cond7}, o programa continuará verificando as condições especificadas dentro dos if's enquanto não for encontrada uma condição verdadeira. Se nenhuma condição verdadeira for encontrada, executar-se-ão os procedimentos dentro do else, caso este tenham sido especificado (pode-se escrever uma série de else -if's sem um else final). 

\begin{lstlisting}[ caption =  Sintaxe do bloco if - (else if) - else (if-else aninhados), label=cond7,]
if(condicao1)
{
	procedimentos1;
}
else if(condicao2)// verifica a condicao2 se a condicao1 eh falsa
{   
	procedimentoElse1;
}
else if(condicao3) // verifica a condicao3 se as condicoes 1 e 2 sao falsas
{
	procedimentosElse2;
}
.
.
.
else if(condicaoN)//verifica a condicaoN se as condicoes 1,2...N-1 sao falsas
{
	procedimentosElseN
}
else // executa os procedimento especificados se todos condicoes 1, 2, ... N 
{    // sao falsas
  
   procedimentosElse;
}
\end{lstlisting}


O código \ref{cond7_2} mostra um exemplo de uso do bloco if - (else if) - else (if-else aninhados).

\begin{lstlisting}[ caption =  Exemplo de uso do bloco if - (else if) - else, label=cond7_2,]
if(sensor > 300)
{            
digitalWrite(2,HIGH);
}
else if(sensor2 > 300)
{
digitalWrite(3,HIGH);
contador2 = contador + 1;
}
else
{
digitalWrite(2,LOW);
digitalWrite(3,LOW);
contador = 0;
contador2 =0;
}
\end{lstlisting}


Pode-se usar blocos condicionais dentro de blocos condicionais. O código \ref{cond7_3} mostra um exemplo disso:

\begin{lstlisting}[ caption =  Exemplo de uso do bloco if - (else if) - else, label=cond7_3,]
if(sensor > 300)
{            
	digitalWrite(2,HIGH);
	if(sensor2 > 100)
	{ 
		if(sensor3 > 100)//executa essa verificao apenas se a verificao
		{				 // (sensor2 > 100) for verdadeira
			digitalWrite(3,HIGH);
		}
		else
		{
			digitalWrite(3,LOW);
		}
	}
}
else if(sensor2 > 300)// executa essa verificacao se a condicao (sensor > 300)
{					  // for falsa	
digitalWrite(3,HIGH);
contador2 = contador + 1;
}
\end{lstlisting}



O operador switch - case opera segundo a sintaxe mostrada no código \ref{cond8}. O bloco switch - case realiza a verificação da igualdade da variável especificada dentro dos parênteses do switch com relação aos valores especificados nos case's. 

Quando uma das verificações propostas nos case's se mostra verdadeira, os procedimentos especificados. Após a execução de tais procedimentos, encontra-se o procedimento \textbf{break;}. O procedimento break faz com que o programa pule para fora do bloco switch, ignorando todos os outros case's não verificados.

Caso nenhum dos case's seja verdadeiro, executa-se os procedimentos especificados no bloco \textit{default:}.

\begin{lstlisting}[ caption =  Sintaxe do switch - case, label=cond8,]
switch (var) { // seleciona a variavel var para ser comparada em todos os
				 // case's até achar um que seja verdadeiro, caso nenhum seja  
				// achado, executa-se os procedimentos default
case Valor1 :// if (var == Valor1)

procedimentos1;

break;

case Valor2 : // if (var == Valor2)

procedimentos2;

break;

.
.
.

case ValorN :// if (var == ValorN)

procedimentosN;

break;

default: 

procedimentosDefault;
}
\end{lstlisting}



O código \ref{cond8_2} mostra um exemplo de aplicação do bloco switch - case.


\begin{lstlisting}[ caption =  Exemplo de uso do bloco switch - case, label=cond8_2,]

int botao = digitalRead(4); // ler o pino digital 3
switch (botao) { // seleciona a variavel botao para ser comparada em todos os
// case's até achar um que seja verdadeiro, caso nenhum seja  
// achado, executa-se os procedimentos default
case  HIGH:

digitalWrite(2, HIGH);
digitalWrite(3, LOW);

break;

case LOW:

digitalWrite(2, LOW);
digitalWrite(3, HIGH);

break;

default: 

digitalWrite(2, LOW);
digitalWrite(3, LOW);
} 
\end{lstlisting}


O operador \textbf{?} ou \textit{ternário} possui a sintaxe mostrada no código \ref{cond9}. Caso a condição especificada for verdadeira, o valor ou variável especificada à esquerda dos dois pontos (:) é escolhida para ser atribuída a variável \textit{var}. Caso a condição especificada for falsa, o valor ou variável especificada à direita dos dois pontos (:) é escolhida para ser atribuída a variável \textit{var}.



\begin{lstlisting}[ caption =  Sintaxe de utilização do operador \textbf{?}, label=cond9,]
var = (condicao) ? selecionaSeCondicaoVerdadeira : selecionaSeCondicaoFalsa;

//O ternário acima é equivalente a

if(condicao)
{
	var = selecioaSeCondicaoVerdadeira;
}
else
{
	var = selecionaSeCondicaoFalsa;
}
 
\end{lstlisting}

Um exemplo da aplicação do operador \textbf{:} é mostrado no código \ref{cond9_2}.

\begin{lstlisting}[ caption =  Exemplo de uso do operador \textbf{?}, label=cond9_2,]
int i = 2;
int var;
var = (i > 1) ? 100 : 200;

//O ternário acima é equivalente a

if( i > 1)
{
	var = 100;
}
else
{
	var = 200;
}
 
\end{lstlisting}

\subsection{Laços de repetição}
\label{EmbassamentoSoftware_Lacos}

No codificação de muitos algoritmos, é usual existir a necessidade de repetir certos comandos um determinado número de vezes ou até que certa condição seja atingida. 

Uma solução rápida para conseguir realizar certos comandos um número determinado de vezes seria repetir o código o número de vezes desejado, simplesmente copiado as linahs de código desejadas, como mostrado no código \ref{codLoop1}.
  
  
 \begin{lstlisting}[ caption =  Uma possível solução para repetir um comando um número determinado de vezes, label=codLoop1,]
 
 // REPETINDOS OS COMANDO1 até COMANDON 3 VEZES
 // COPIANDO E COLANDO AS LINHAS DESEJADAS
 
 comando1;
 comando2;
 .
 .
 .
 comandoN;
 
 comando1;
 comando2;
 .
 .
 .
 comandoN;
 
 comando1;
 comando2;
 .
 .
 .
 comandoN;
 
 \end{lstlisting}
 
 Isso tipo de solução para o problema da necessidade de repetição de código, além de poder trazer diversas erros na produção do código, deixa o código grande e limitado.
 
 Para facilitar a codificação de trechos de códigos que devem ser repetidos certo números de vezes ou até que certa condição seja atingida, existem os \textit{laços de repetição}.
 
 Na linguagem de programação C, existem os seguintes estruturas para criar laços:
 
 \begin{enumerate}
 	\item Laço for
 	\item Laço while
 	\item Laço do-while
 \end{enumerate}
 
 Nesta seção, essas 3 estruturas serão apresentadas.
 
 \subsubsection{Laço for}
 
 O laço \textit{for} serve, primariamente, para repetir certos comando um determinado número de vezes. A Figura \ref{loop1} mostra a sintaxe para o uso do operador for. Primeiramente, deve-se escrever a palavra \textbf{loop} e abrir parênteses. 
 
 A região na Figura \ref{loop1} indicada por \textbf{Inicialização de contador} será usada, como dito, para atribuir à variável responsável por contar quantas vezes o loop já foi executado com alguma valor.  
 
  A região na Figura \ref{loop1} indicada por \textbf{atualização de contador} será usada, como dito, para , de alguma maneira desejada, atualizar a variável responsável por contar quantas vezes o loop já foi executado. Usualmente se executa $contador = contador + 1$ nessa região a cada vez que o loop é executado.
  
  A região na Figura \ref{loop1} indicada por \textbf{teste de condição de fim de loop} será usada, como dito, para verificar se o loop deve continuar a ser executado ou não. Caso a verificação lógica executada nessa região resulte em FALSE, o loop será encerrado e o programa continuará a executar as instruções abaixo do loop .   
  
 \begin{figure}[H]
 \centering
 \includegraphics[width=0.7\textwidth]{figs/loop1.jpg}
 \caption{Sintaxe de uso do loop for.}
 \label{loop1}
 \end{figure}
 
 
 Um exemplo de uso de um loop for é mostrado na Figura \ref{loop2}. Nesse exemplo, uma inteira variável chamada \textit{cont}, foi inicializada com o valor 0, na região indicada por \textbf{inicialização de contador} na Figura  \ref{loop1}. 
 
 Num primeiro instante, a verificação lógica da região descrita por \textbf{teste de condição de fim de loop} $cont < 10$ será executada. Ou seja, a verificação $0 < 10$ será verificada. Tal verificação lógica resultará em TRUE, portanto o loop continuará. 
 
 Dentro do loop, existe a instrução $digitalWrite(cont, HIGH);$. Como ovalor atual de cont é 0, a instrução é equivalente, nesse instante a $digitalWrite(0, HIGH);$, ou seja, a porta digital 0 apresentará um valor alto de tensão após isso.
 
 Após todas instruções internas ao loop serem executadas, será executada a instrução relativa a região \textbf{atualização contador}. No exemplo mostrado, a atualização do contador é a seguinte $cont = cont + 1$, ou seja, $ cont = 0(antigo valor de cont) + 1 -> cont = 1$.
 
 Esse mesmo padrão se repetirá, fazendo com que as porta 0 até 9 sejam setadas com valor alto de tensão. 
 
 Quando a variável cont chegar ao valor 10, a verificação lógica $ cont < 10$ não mais será verdadeira, e o laço será finalizado.

 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.7\textwidth]{figs/loop2.jpg}
 	\caption{Exemplo de uso do loop for.}
 	\label{loop2}
 \end{figure}
 
 Um aspecto importante a ser destacado para todas estruturas de repetição na linguagem C é que todas variáveis usadas nas regiões que definem a estrutura do loop devem ser declaradas anteriomente ao loop.
 
 As variáveis declarada interiormente ao loop não poderão fazer parte das regiões que definem o loop.
 
 O código \ref{loop3} mostra alguns erros comuns na utilização do loop for 
 
 \begin{lstlisting}[ caption =  Alguns erros comuns a utilizar loops em C, label=loop3,]
 
 for(i = 0; i < 10; i = i -1)
 {
    int soma;
	soma = soma + i;
     
     //ERRO 1: variavel i não declarada antes do loop
     //ERRO 2: Esse erro possivelmente não será detectado pelo
     // pelo compilador. Ao executar esse loop, a condição de fim
     // de loop nunca será falsa, devido a forma de atualização 
     // contador
     //ERRO 3: A variavel definida no interior do loop é somada
     // consigo mesma e com o contador, entretanto, a variável 
     // soma não possui valor inicial, causando um possível erro
     // em tempo de execução 
 }
 
 soma = soma + 10;
 // ERRO 4: A variável soma é definida apenas interiomente ao //loop referênciá-la fora do loop não é possível
 
 
 \end{lstlisting}
 
Já o código \ref{loop4} mostra o mesmo código mostrado em \ref{loop3} corrigido.
\begin{lstlisting}[ caption = Código sem erros, label=loop4,]

//DEFININDO CONTADOR E VARIAVEL A SER USADA FORA DO
//LOOP ANTES DO LOOP
int soma = 0;
int i;

for(i = 0; i < 10; i = i +1)// USANDO UMA APROPRIADA DE ATUALIZA
{							//-CAO DE CONTADOR
soma = soma + i;
}

soma = soma + 10;


\end{lstlisting}
  

\subsubsection{Laço while}

O laço \textit{while} serve, primariamente, para repetir certos comando enquanto certa condição não for atingida. A Figura \ref{} mostra a sintaxe comum de utilização do laço \textit{while}.

  
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.7\textwidth]{figs/loop5.jpg}
 	\caption{Sintaxe comum de uso do loop while.}
 	\label{loop5}
 \end{figure}
  
  
  A região na Figura \ref{loop5} indicada por \textbf{Inicialização de contador ou variável para verificação de quebra de fim loop} será usada, como dito, para atribuir à variável responsável por contar quantas vezes o loop já foi executado com alguma valor ou inicializar a variável que a cada loop irá servir para verificar se a condição de fim de loop já foi atinginda.  
  
  A região na Figura \ref{loop5} indicada por \textbf{teste de condição de fim de loop} será usada, como dito, para verificar se o loop deve continuar a ser executado ou não. Caso a verificação lógica executada nessa região resulte em FALSE, o loop será encerrado e o programa continuará a executar as instruções abaixo do loop .   
  
  A região na Figura \ref{loop5} indicada por \textbf{atualização de contador} será usada, como dito, para , de alguma maneira desejada, atualizar a variável responsável por indicar que o loop chegou ao fim. 
  
  
  O código \ref{loop6} mostra um exemplo de uso do while.
  
\begin{lstlisting}[ caption = Exemplo de uso do laço while, label=loop6,]
  //Inicialização de contador ou variável para verificação de //quebra de fim loop
  int soma = 0;
  int i = 0;
  
  while (i < 100) //teste de condição de fim de loop
  {
     soma = soma + 1 // procedimento1
     
     i = i + 1; //Atualizacao de contador ou variavel de         
				// verificacao
  }
  
\end{lstlisting}


Ao iniciar o loop \textit{while}, a primeira coisa que acontece é a verificação da condição de fim de loop. 

No exemplo mostrado no código \ref{loop6}, a variável usada como contador é a variável \textbf{i}. Ela é inicializada com o valor 0. O teste de fim de loop, no primeiro instante, é, portanto, o seguinte: ( 0 < 100 ). Essa verificação lógica terá como resultado TRUE, daí, o loop será executado. 

A cada iteração do loop while citado, a variável \textbf{i} terá seu valor incrementado  por uma unidade. 

Quando \textbf{i} for igual a 100, o loop while será finalizado.

Um dos usos muito comuns para o loop while, é a verificação do estado de certa variável de software ou de hardware. O código  \ref{loop7} mostra essa aplicação para o loop while num programa feito para a placa Galileo.

\begin{lstlisting}[ caption = Exemplo de uso do laço while para a placa Galileo, label=loop7,]

#define botao1 2
#define led 3
void setup()
{
pinMode(botao1, INPUT);
pinMode(led, OUTPUT);
}

void loop()
{
	delay(100);
	digitalWrite(led, LOW);
     
    //Enquanto o botao conectado a porta digital 2
    //nao for apertado
    //repete o loop while sem fazer coisa alguma
    //alem de verificar o estado do botao
	while(digitalRead(botao1) != HIGH)
	{
	}
	
	
	//botao apertado, pisca LED
	digitalWrite(led, HIGH);

}

\end{lstlisting}



\subsubsection{Laço do-while}

O laço \textit{do-while} possui o mesmo comportamento do laço while. A única diferença é que, ao usar o \textit{do-while} é garantido que as instruções internas ao loop serão executadas pelo menos uma vez. Isso deve ao fato de que a verificação de fim de loop só ocorre ao final do loop.

A sintaxe do \textit{do-while} é como mostrado na Figura \ref{loop8}


 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.7\textwidth]{figs/loop8.jpg}
 	\caption{Sintaxe comum de uso do loop do-while.}
 	\label{loop5}
 \end{figure}
 
 Um exemplo de uso do \textit{do-while} é mostrado no código \ref{loop9}:


\begin{lstlisting}[ caption = Exemplo de uso do laço while para a placa Galileo, label=loop7,]

#define botao1 2
#define led 3
void setup()
{
pinMode(botao1, INPUT);
pinMode(led, OUTPUT);
}

int flag = 0;
void loop()
{ 
	if(flag == 0)
	{
		do{
		
			delay(100);
			digitalWrite(led, LOW);
			delay(100);
			digitalWrite(led, HIGH);			
		
		}while(digitalRead(botao1) != HIGH);
	}
	
	flag = 1;
}

\end{lstlisting}


Esse exemplo possui o comportamento contrário ao comportamento do código \ref{loop7}. Nesse exemplo, o LED piscará continuamente atéque o botão seja apertado. Quando o botão for apertado, o programa saíra do loop e a variável \textit{flag} será setada com o valor 1. Ao fazer isso, não mais o programa executará o laço do-while, por causa da verificação \textit{if( flag == 0)}.



\subsection{Vetores e Matrizes}
\label{EmbassamentoSoftware_VetoresMatrizes}

Vetores, também chamados de arrays, e matrizes são conjunto de dados de mesmo tipo. São usadas para tratar grandes quantidades de dados sem a necessidade de declaração de muitas variáveis.

 Nesta seção, serão tratados os conceitos de vetores e matrizes alocadas estaticamente na memória(antes da execução do programa) de forma detalhada. Na seção \ref{EmbassamentoSoftware_TiposAvancados} serão tratadas, além de outros tipos mais avançados de variáveis, vetores e matrizes alocadas dinamicamente, ou seja, durante o tempo de execução do programa. 

\subsubsection{Vetores}

Vetores são conjuntos de dados para serem tratados em apenas uma dimensão de indexação. A Figura \ref{fig_vetor1} mostra a alocação para \textit{N} espaços de memória para um vetor.  

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{figs/fig_vetor1.jpg}
	\caption{Alocação de memória para um vetor declarado para N espaços de memória.}
	\label{fig_vetor1}
	\source{Adaptado de http://www.tiexpert.net/programacao/c/vetores.php}
\end{figure}


 O código \ref{vetor1} mostra a sintaxe de declaração de um vetor em C.


\begin{lstlisting}[ caption = Sintaxe de declaração de um vetor em C, label=vetor1,]
tipo nome_da_variavel [quantidade_de_elementos];
\end{lstlisting}

Exemplo de declaração de vetores de vários tipos de dados são mostrados no código \ref{vetor2}.

\begin{lstlisting}[ caption = Exemplos de declaração de um vetor em C, label=vetor3,]

//DECLARACAO DE VETORES DE VARIOS TIPOS DE VARIAVEIS

int v_int [100]; //declara um vetor de 100 inteiros 
char v_char[100];//declara um vetor de 100 caracteres

float v_float[100];//declara um vetor de 100 numero racionais

\end{lstlisting}


Nos exemplos de declaração do código \ref{vector2}, são declarados conjuntos de dados sequenciais. 

Para acessar, atribuir ou modificar os elementos de um vetor, a sintaxe do código \ref{vector3} é usada.

\begin{lstlisting}[ caption = Sintaxe de atribuição de um valor a certo índice num vetor, label=vetor3,]
tipo nome_da_variavel [quantidade_de_elementos];

nome_da_variavel[indice] = valor;

\end{lstlisting}


Exemplos de atribuição de valor a certos índices em vetores são mostrados no código \ref{vetor4}.


\begin{lstlisting}[ caption = Exemplos de declaração de um vetor em C, label=vetor4,]

int v_int [100]; //declara um vetor de 100 inteiros 
int vetor_digitos [10];//declara um vetor de 10 inteiros
char v_char[100];//declara um vetor de 100 caracteres
float v_float[100];//declara um vetor de 100 numero racionais

v_int[0] = 1;// atribuicao do valor 1 ao primeiro elemento do
			 // do vetor v_int

vetor_contagem = {0,1,2,3,4,5,6,7,8,9}; // atribuicao de um 
										// bloco completo de 
										// dados ao vetor
		
v_char[0] = 'd'; // atribuicao do char 'd' no primeiro espaco de 
				 // memoria reservado para a variavel v_char
				 
v_int{9} = 234567;// atribuicao do valor 234567 ao espaco de 
				  // memoria 10 da variavel v_int
				  
v_float[49] = 0.52// atribuicao do valor 0.52 ao espaco 50 
				  // do vetor v_float
\end{lstlisting} 


Um fato extremamente importante a ser pontuado com relação à indexação de vetores e matrizes é que a contagem sempre começa pelo valor 0. O código acima mostra vários exemplos nos quais tal fato foi pontuado nos comentários.

Vetores e matrizes são muitas vezes utilizados em conjuntos com laços de repetição.

O exemplo do código \ref{vetor5} mostra a utilização de um laço for em conjunto com o um vetor de 10 números inteiros.

\begin{lstlisting}[ caption = Exemplos de uso de um for com um vetor, label=vetor5,]

//SUPONDO QUE EXISTE UM VETOR De INTEIROS int vetor[10]
//JAH COM VALORES SETADOS EM TODOS INDICES

int i;
int soma = 0;
for(i = 0; i < 10; i++)
{
	soma += vetor[i];
}

//A VARIAVEL soma TEM AGORA A SOMA DE TODOS FATORES 

\end{lstlisting} 

O exemplo acima também mostra o acesso de cada índice do vetor.

\subsubsection{Matrizes}

Pode-se dizer que matrizes são vetores bidimensionais. Há 2 ou mais dimensões de indexação numa matriz.

\begin{lstlisting}[ caption = Sintaxe de declaração de uma matriz em C, label=matriz1,]
tipo nome_da_variavel [quantidade_de_elementos_dimensao1][quantidade_de_elementos_dimensao2]...[quantidade_de_elementos_dimensaoN];
\end{lstlisting}


O código \ref{matriz2} mostra um exemplo de declaração e  iniciação de uma matriz 5x3. Nessa matriz há 15 números inteiros organizados em 5 linhas e 3 colunas.


\begin{lstlisting}[ caption =  Exemplo de declaração e iniciação de uma matriz de inteiros em C, label=matriz2,]
int alunos_notas [5][3] = {  9,7,9;
							  10,8,6;
							  5,4,5;
							  6,6,6;
							  7,9,8;
							};
\end{lstlisting}

A primeira atribuição do exemplo \ref{matriz2} (número 9)  é destinada ao elemento (0,0), ou seja, $alunos\_notas [0][0] = 9$.Cada virgula simboliza atribuição à próxima coluna, na linha atual, ou seja, $alunos_notas [0][1] = 7$. Todo ponto e vírgula simboliza "pulo de linha". Após o primeiro ponto e vírgula, tem-se a atribuição do número 10, ou seja, $alunos\_notas [1][] = 10$.

O exemplo \ref{matriz3} usa a mesma matriz declarada e iniciada no código \ref{matriz2}, para calcular a média de 5 alunos em 3 provas e atribuir tal média a um vetor de floats chamado $medias$. 


\begin{lstlisting}[ caption =  Exemplo de usod e matriz bidimensional, label=matriz3,]

int alunos_notas [5][3] = {  9,7,9;
10,8,6;
5,4,5;
6,6,6;
7,9,8;
}; //Declaracao e atribuicao de valores de notas de 3 provas a 5 //alunos

float medias [5];//media dos 5 alunos a serem calculadas
int i,j;// variaveis a serem usadas como contadores de lacos
		// e indices de matriz
		
for(i = 0; i < 5; i++)
{
	for(j = 0; < 3;j++)
	{	
		// Calculando a media do aluno i
		// notar a conversao de variavel
	   medias[i] = (float)alunos_notas[i][j]/3; 
	}
}		
		
\end{lstlisting}


No exemplo, é executado o comando $ medias[i] = (float)alunos\_notas[i][j]/3$. A conversão para float, como explicado na seção \ref{EmbassamentoSoftware_ConversaoEntreVariaveis}, é necessária. A primeira razão é que a variável $medias$ é uma matriz de floats. Em geral, os compiladores já fazem essa compilação automaticamente. A segunda, e mais relevante para este exemplo, é que a operação $alunos\_notas[i][j]/3$ resultaria , sem a conversão, num número inteiro, não num número racional, causando erros no cálculo.


\subsection{Tipos avançados de variáveis}
\label{EmbassamentoSoftware_TiposAvancados}

Além dos tipos básicos de variáveis ( seção \ref{EmbassamentoSoftware_TiposVariaveis}), existem tipos mais complexos e com usabilidade muitas vezes mais úteis na codificação de programas. 

Para a plataforma de programação utilizada com Arduino e Galileo são utilizados os tipos mostrados na tabela \ref{avancado1}. Os tipos destacados em vermelho são os tipos mais avançados a serem tratados nesta seção.
\begin{table}[H]


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/tiposAvancados1.jpg}
\end{figure}
\caption{Tipos básicos e avançados ( destacados em vermelho) de variáveis.}
\label{avancado1}
\source{Adaptado de http://playground.arduino.cc/Code/DatatypePractices}
\end{table}

\subsubsection{boolean}

O tipo boolean é um tipo muito simples de dado utilizado para programação em Arduino. 

Muitas vezes, se deseja saber do estado atual de algo e para isso se pode manipular variáveis do tipo \textit{boolean}.

Variáveis do tipo boolean podem armazenar apenas dois valores: \textit{true ou false}.

Como a unidade mínima de endereços de variáveis nas arquiteturas atuais é o byte, o qual possui 8 bits, portanto, o boolean, como mostrado na tabela \ref{avancado1} ocupa 1 byte de memória e não apenas 1 bit, como esperado.

O código \ref{boolean1} mostra um exemplo de uso de uma variável boolean.

\begin{lstlisting}[ caption =  Exemplo de uso de uma variável boolean em Arduino, label=boolean1,]
#define pinoBotao 2
boolean botaoApertado = false;

if(digitalRead(pinoBotao) == HIGH)
{
	botaoApertado = true;
}

\end{lstlisting}


\subsubsection{Ponteiros}
\label{Ponteiros}

Ponteiros, são, como qualquer variável em C, variáveis que armazenam no espaço de memória a ela reservado uma série de bits com algum significado determinado.

A diferença de um ponteiro para uma variável normal é que ele tem como conteúdo, não um número qualquer ou caractere, mas um \textbf{endereço de memória}. 

A sintaxe para declaração de um ponteiro é mostrado no código \ref{pont1}.

\begin{lstlisting}[ caption = Sintaxe de declaração de um ponteiro em C, label=pont1,]
tipo *nome_do_ponteiro;
\end{lstlisting}

Exemplos de ponteiros para vários tipos de memória s'ao mostrados no código \ref{pont2}.


\begin{lstlisting}[ caption = Exemplos de declaração de um ponteiro em C, label=pont3,]
int * ptrInt; // ponteiro para armazenar o endereço de um int
char * ptrChar; // ponteiro para armazenar o endereço de um char
float *ptrFloat;// ponteiro para armazenar o endereço de um float
double *ptrDouble;// ponteiro para armazenar o endereço de um 
				  // double
\end{lstlisting}


\begin{lstlisting}[ caption = Exemplos de atribuição de endereços de variáveis a ponteiros, label=pont4,]
int * ptrInt; // ponteiro para armazenar o endereço de um int
char * ptrChar; // ponteiro para armazenar o endereço de um char
float *ptrFloat;// ponteiro para armazenar o endereço de um float
double *ptrDouble;// ponteiro para armazenar o endereço de um
				  // double


char c = 'f';
prtChar = &c; // no ponteiro ptrChar tem agora o endereco da 
			  // variavel c
			  
int v[10] = {5,10,15,3,10,76,5,13,33,45};
prtInt = &v; //prtInt APONTA para o endereco 
	         // inicial do vetor v, cujo 
			// conteudo eh igual a 5
			
			
 

\end{lstlisting}


No código\ref{pont4}, o ponteiro \textit{ptrChar} recebe o endereço de memória da variável \textit{c} e o ponteiro \textit{ptrInt} recebe o endereço do primeiro inteiro do vetor de inteiros \textit{v}.

 A Figura \ref{pont3} a alocação de memória para o vetor \textit{v} supondo que o endereço de memória atribuído para v se deu a partir de 108. 
 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/pont3.jpg}
	\caption{Endereço de memória e conteúdo de um vetor \textit{v} de 8 espaços.}
	\label{pont3}
\end{figure}

Após o comando $ ptrInt = \&v$ se executado, o ponteiro \textit{ptrInt} passou a apontar para o endereço da primeira variável do vetor \textit{v} como mostrado na Figura \ref{pont4}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{figs/pont4.jpg}
	\caption{Após a atribuição do endereço do vetor ao ponteiro ptrInt.}
	\label{pont4}
\end{figure}



Ponteiros permitem que você se referem ao mesmo espaço na memória de vários locais no programa. Isso significa que se pode atualizar a memória em um local e a mudança pode ser vista em outros escopos. 

Ponteiros também podem ser interessantes para economizar espaço por possibilitar o compartilhamento de componentes em estruturas de dados.

Ponteiros também podem ser usados para navegar em matrizes e vetores. Usando o mesmo exemplo do código \ref{pont3} no código \ref{pont5}, ao ser executar o laço mostrado, o conteúdo do vetor seria ${7,12,17,5,12,78,7,15,35,47}$. O operado $*ptrInt$ refere-se ao conteúdo armazenado no endereço de inteiro apontado por $ptrInt$, assim como $*(ptrInt +1)$, se refere do próximo endereço de ponteiro apontado por $ptrInt.$


\begin{lstlisting}[ caption = Exemplos de atribuição de endereços de variáveis a ponteiros, label=pont4,]
int * ptrInt; // ponteiro para armazenar o endereço de um int
char * ptrChar; // ponteiro para armazenar o endereço de um char
float *ptrFloat;// ponteiro para armazenar o endereço de um float
double *ptrDouble;// ponteiro para armazenar o endereço de um
				  // double

char c = 'f';
prtChar = &c; // no ponteiro ptrChar tem agora o endereco da 
// variavel c

int v[10] = {5,10,15,3,10,76,5,13,33,45};
prtInt = &v; //prtInt APONTA para o endereco 
// inicial do vetor v, cujo 
// conteudo eh igual a 5

int i;

for(i = 0; i < 10; i++)
{
   *(ptrInt + i) = *(ptrInt + i) + 2; //adiciona 2 ao i-esimo
									   // conteudo do vetor v
	
	//comando com efeito igual ao comando anterior
	//ptrInt[i] += 2;								    
									   
}


\end{lstlisting}

\subsubsection{String e Arrays}

String e array são nada mais do que vetores de caracteres ou vetores de qualquer tipo de variável (visto que array se define para qualquer tipo de variável).

Esta subseção está escrita após a subseção relativa a ponteiros ( subseção \ref{Ponteiros}) devido ao fato de que o comando relativo a alocação dinâmica de memória ( alocação quando o programa já passou a ser executado) necessitar de conceito de atribuição de endereço de blocos de memória.


String em C são tratadas com o tipo $char *$, ou seja, um ponteiro de char.

O código \ref{string1} mostra uma alocação estática de uma string. O conjunto de caracteres "MINHASTRING" é alocado em certo espaço do heap de memória pelo compilador e o ponteiro string aponta para o primeiro caractere do conjunto de caracteres.  

\begin{lstlisting}[ caption = Exemplos de uma alocação estática de uma string em C, label=string1,]

char * string = "MINHASTRING";

//          +-+-+-+-+-+-+-+-+-+-+-+
//string -> |M|I|N|H|A|S|T|R|I|N|G|  ponteiro string aponta para
//          +-+-+-+-+-+-+-+-+-+-+-+  esse bloco de memoria 
									// no heap de memoria
\end{lstlisting}


O código \ref{string2} mostra uma alocação dinâmica de uma string. Para se alocar dinamicamente um bloco de memória deve-se utilizar o comando \textit{malloc(NUMBYTES)}. O comando malloc reserva, em tempo de execução, a quantidade de bytes especificados como argumento de entrada e atribui o endereço inicial do bloco ao ponteiro especificado.


\begin{lstlisting}[ caption = Exemplos de uma alocação dinâmica de uma string em C, label=string2,]

char * string = (char *)malloc(11);

//          +-+-+-+-+-+-+-+-+-+-+-+
//string -> |X|X|X|X|X|X|X|X|X|X|X|  ponteiro string aponta para
//          +-+-+-+-+-+-+-+-+-+-+-+  esse bloco de memoria 
								  // reservado para 11 bytes
								  
//          +-+-+-+-+-+-+-+-+-+-+-+
//		    |X|X|X|X|X|X|X|X|X|X|X| 
//          +-+-+-+-+-+-+-+-+-+-+-+ 
//
//          +-+-+-+-+-+-+-+-+-+-+-+
//string -> |M|I|N|H|A|S|T|R|I|N|G|  ponteiro string aponta para
//          +-+-+-+-+-+-+-+-+-+-+-+  esse bloco de memoria, nao
									// o reservado acima 
 
								  
\end{lstlisting}

O conjunto de caracteres "MINHASTRING", caso atribuído à variável string ($string ="MINHASTRING"$) não será atribuído aos 11 bytes alocados, mas para outro bloco, não reservado. É possível que ao tentar acessar o conteúdo da string após o comando $string ="MINHASTRING"$ cause um erro em tempo de execução.

A forma correta de atribuição uma string para um ponteiro de char é mostrado  \ref{string3}.


\begin{lstlisting}[ caption = Atribuição de string a um ponteiro de char alocado dinamicamente, label=string3,]

char * string = (char *)malloc(11);

//          +-+-+-+-+-+-+-+-+-+-+-+
//string -> |X|X|X|X|X|X|X|X|X|X|X|  ponteiro string aponta para
//          +-+-+-+-+-+-+-+-+-+-+-+  esse bloco de memoria 
// reservado para 11 bytes

strcpy(string,"MINHASTRING");
//          +-+-+-+-+-+-+-+-+-+-+-+
//string -> |M|I|N|H|A|S|T|R|I|N|G|  
//          +-+-+-+-+-+-+-+-+-+-+-+  



\end{lstlisting}

Como dito, arrays alocados dinamicamente podem ser criados, utilizando o comando malloc, para qualquer tipo de variável.

O código \ref{string4} mostra a alocação dinâmica de um array de 11 floats. O comando sizeof(TIPO) retorna a quantidade de bytes que o tipo de variável especificado por \textit{TIPO} possui.
No caso do exemplo, uma variável float ocupa 4 bytes, portanto, serão reservados 44 bytes de memória e o endereço de tal bloco atribuído ao ponteiro arrayFloats. 

\begin{lstlisting}[ caption = Alocação dinâmica de um array de 11 floats, label=string4,]
int numFloats = 11ç
float * arrayFloats = (float *)malloc(11*sizeof(float));

//          	+-+-+-+-+-+-+-+-+-+-+-+-+-+
//arrayFloats -> |X|X|X|X|X|X|X|X|X|X|X|  
//               +-+-+-+-+-+-+-+-+-+-+-+  esse bloco de memoria 
// reservado para 11 espaços ocupados por floats(4*11 bytes)


\end{lstlisting}

Para se acessar os elementos de um array, pode-se utilizar qualquer uma das sintaxes mostrada no exemplo \ref{string5}. Caso a operação $arrayFloats++;$ seja executada, o ponteiro arrayFloats passará a apontar não mais para o primeiro endereço alocado, mas para o segundo. A letra N no comentário mostrado após o comando $arrayFloats++;$ simboliza um espaço de memória não alocado com o comando malloc. 

Abaixo do comando $arrayFloats++;$ é mostrado uma série de comandos que podem causar erros em tempo de execução por causa da tentativa de acesso a espaço de memória não reservados.


\begin{lstlisting}[ caption = Alocação dinâmica de um array de 11 floats, label=string4,]
int numFloats = 11;
float * arrayFloats = (float *)malloc(numFloats*sizeof(float));

arrayFloats[2] = 7.8;
*(arrayFloats + 1) = 0.5;

//          	+--+-+--+---+---+-+-+-+-+-+-+-+-+
//arrayFloats -> |X|0.5|7.8|X|X|X|X|X|X|X|X|  
//               +-+-+-+-+-+-+-+-+-+-+-+-+-+  esse bloco de //                                           //memoria 
// reservado para 11 espaços ocupados por floats(4*11 bytes)

arrayFloats++;

//          	 +---+---+---+-+-+-+-+-+-+-+
//arrayFloats -> |0.5|7.8|X|X|X|X|X|X|X|X|N| // arrayFloats
//               +-+-+-+-+-+-+-+-+-+-+-+-+-+//passa a apontar 
											// para o endereco do
											//0.5

if(arrayFloats[10] == 0.0)//possível erro em tempo de execucao
   arrayFloats[10] = 1.0; // 

\end{lstlisting}


Para alocar dinamicamente uma matriz, deve-se usar ponteiro de ponteiros e laços de repetição, como mostrado no código \ref{string5}. Pode-se ver um $int **$ (ou um ponteiro de ponteiro de qualquer tipo de variável) como um array de ponteiros de int. Cada um desses ponteiros nesse array deve-se ter seu espaço de memória alocado, como mostrado no código.

\begin{lstlisting}[ caption = Alocação dinâmica de uma matriz 2X2 de inteiros, label=string5,]

int **matriz = (int **)malloc(2*sizeof(int *));
int i,j;

for(i = 0; i <2;i++)
{
	matriz[i] = (int *)malloc(2*sizeof(int));
}

//    	   +-+-+		
//matriz ->|X|X|
//		   +-+-+
//		   |X|X|
//         +-+-+

for(i = 0; i <2;i++)
{
	for(j = 0; j <2;j++)
	{
		matriz[i][j] = i + j;
	}
}

//    	   +-+-+		
//matriz ->|0|1|
//		   +-+-+
//		   |1|2|
//         +-+-+
	


\end{lstlisting}




\subsubsection{Registros - Struct}
\label{Struct}

Em C, registros são nomeados por \textit{structs}. Chama-se por registro um conjunto de variáveis de tipos quaisquer. Cada variável em um registro é chamado de \textit{campo}. 

O exemplo \ref{struct1} mostra a sintaxe de uma struct em C.

\begin{lstlisting}[ caption =  Sintaxe de definição de uma struct, label=struct1,]
//Definicao de uma struct
typedef struct  {
TIPO1 VAR1;
TIPO2 VAR2;
.
.
.
TIPON VARN;
} NOME_STRUCT;

//variavel do tipo NOME_STRUCT 
NOME_STRUCT struct1;

void setup()
{
struct1.VAR1 = ...;
struct1.VAR2 = ...;
.
.
.
struct1.VARN = ...;
} 

void loop()
{
struct1.VAR1 = ....
if(struct1.VAR2....)
.
.
.
//Outros procedimentos
}
\end{lstlisting}


O uso dos símbolos \textit{typedef} não é obrigatório para definição e uso de struct, entretanto, ao utilizá-lo, pode-se declarar uma varíavel do tipo da estrutura como um novo tipo de dados semelhantes aos tipos básicos (int, char, etc).

O código \ref{struct2} mostra um exemplo de uma struct que acumula variáveis relevantes para um programa que lide com dados de estudantes, por exemplo.


\begin{lstlisting}[ caption =  Exemplo de definição e uso de uma struct, label=struct2,]
//Definicao de uma struct com dados relevantes a um estudante
typedef struct  {
char * nome;
int turma;
float notaTrabalho1;
float notaProva1;
float media;

} estudante;

//variavel do tipo NOME_STRUCT 
estudante aluno1;

float calculaMedia(estudante est)
{
  return (est.notaTrabalho1 + est.notaProva1)/2;
}

void setup()
{
aluno1.nome = "Luiz"; // setando a variavel nome (cuidado com //possivel erro de memoria nessa setagem de ponteiro de char )

aluno1.turma = 25;

aluno1.notaTrabalho1 = 10;
aluno1.notaProva1 = 0;
aluno1.media = calculaMedia(aluno1);//chama funcao calculaMedia
									// para setar o campo media	
									
Serial.begin(9600);									
} 

void loop()
{
Serial.print("Nome Estudante : " );
Serial.println(aluno1.nome);
Serial.print("Nota Trabalho 1 : " );
Serial.println(aluno1.notaTrabalho1);
Serial.print("Nota Prova 1 : " );
Serial.println(aluno1.notaProva1);
Serial.print("Media : " );
Serial.println(aluno1.media);

if(aluno1.media >= 5.0)
{
	Serial.println("Aprovado");	
}
else
{
	Serial.println("Reprovado");
}


}
\end{lstlisting}

Nesse, foi definida uma struct para guardar os dados de um estudante. Os dados são os seguintes : 
\begin{itemize}
	\item Nome
	\item Turma
	\item Nota do trabalho 1
	\item Nota da prova 1
\end{itemize}

Os campos da struct são acessado, como mostrado, usando um ponto, após o nome da variável.

Como os campos da struct são do tipos básicos de variáveis (int, char, etc) eles podem ser tratadas normalmente como tal. 

Struct também podem ser argumentos de entrada ou saída de funções como mostrado no exemplo da função \textit{calculaMedia} do código \ref{struct2}. 

Usando a mesma \textit{struct} do código \ref{struct2}, o código \ref{struct3} mostra como alocar espaço de memória dinamicamente para um ponteiro de struct.


\begin{lstlisting}[ caption =  Exemplo de definição e uso de uma struct, label=struct3,]
//Definicao de uma struct com dados relevantes a um estudante
typedef struct  {
char * nome;
int turma;
float notaTrabalho1;
float notaProva1;
float media;

} estudante;

//variavel do tipo NOME_STRUCT 
estudante * alunos;

float calculaMedia(estudante * est, int numEstudante)
{
return (est[numEstudante]->notaTrabalho1 + est[numEstudante]->notaProva1)/2;
}

void setup()
{

alunos = (estudante *)malloc(2*sizeof(estudante));

aluno[0]->nome = "Luiz"; // setando a variavel nome (cuidado com //possivel erro de memoria nessa setagem de ponteiro de char )

aluno[0]->turma = 25;

aluno[0]->notaTrabalho1 = 10;
aluno[0]->notaProva1 = 0;
aluno[0]->media = calculaMedia(aluno[0]);//chama funcao calculaMedia
// para setar o campo media	

Serial.begin(9600);									
} 

void loop()
{
Serial.print("Nome Estudante : " );
Serial.println(aluno[0]->nome);
Serial.print("Nota Trabalho 1 : " );
Serial.println(aluno[0]->notaTrabalho1);
Serial.print("Nota Prova 1 : " );
Serial.println(aluno[0]->notaProva1);
Serial.print("Media : " );
Serial.println(aluno[0]->media);

if(aluno[0]->media >= 5.0)
{
Serial.println("Aprovado");	
}
else
{
Serial.println("Reprovado");
}


}
\end{lstlisting}


No código \ref{struct3}, é reservado, para o ponteiro da struct, um espaço para duas variáveis do tipo \textit{estudante} por meio do comando \textit{malloc}. 

Para acessar os membros da struct, nesse caso, não se usa ponto, mas o conjunto de caracteres \textit{->}. 



\subsection{Conversão Código Binário para Decimal e vice-versa}
\label{CodigoBinario}
Todo número segue uma base numérica para representação de números.Toda base numérica é um conjunto de símbolos (ou algarismo). 

Representando por C, o número de símbolos da base B (por exemplo, na base hexadecimais, o número é 16) e por \textit{$alg_{n}$} o enésimo algarismo de um número representado na base B, tem-se que todo número, em qualquer base, pode ser convertido da base B para a base decimal seguindo a seguinte fórmula, sendo n o número de expoentes necessários para representar a parte inteira do número e k o número de expoentes necessários para representar a parte fracionária do número:

\begin{equation}\label{eqBaseNumerica}
\begin{split}
Numero_{base Bpara base decimal} = alg_{n}*(C)^{n} + alg_{n-1}*(C)^{n-1} + ...+ alg_{0}*(C)^{0} + ...+ alg_{-k}*(C)^{-k} 
\end{split}
\end{equation}


A base numérica corriqueiramente usada é a base decimal. A base decimal é formada pelo símbolos 0,1,2,3,4,5,6,7,8,9 e a partir deles podem ser representados todos números. O número de símbolos dessa base é 10, portanto, qualquer número, na base decimal, também segue a mesma lógica apresentada na equação \ref{eqBaseNumerica}.  


\begin{equation}\label{eqBaseNumerica2}
\begin{split}
Numero_{base decimal para base decimal} = alg_{n}*10^{n} + alg_{n-1}*10^{n-1} + ...+ alg_{0}*10^{0} + ...+ alg_{-k}*10^{-k} 
\end{split}
\end{equation}

Por exemplo, o número 35,67 na base decimal é igual a :


\begin{equation}\label{eqBaseNumerica3}
\begin{split}
35,67 = 3*10^{1} + 5*10^{0} +6*10^{-1} + 7*10^{-2} 
\end{split}
\end{equation}

A base binária é formada por dois símbolos: 0 e 1. Uma forma usual de se representar um número sem sinal na base binária segue a mesma lógica das expressões mostradas anteriormente:

\begin{equation}\label{eqBaseNumerica4}
\begin{split}
Numero_{base binária para base decimal} = alg_{n}*2^{n} + alg_{n-1}*2^{n-1} + ...+ alg_{0}*2^{0} + ...+ alg_{-k}*2^{-k} 
\end{split}
\end{equation}


Em sistemas digitais, a base binária é sempre utilizada para representar qualquer número de uma forma compreensível para o sistema.

Para converter um número sem sinal representado na base binária para a base decimal (a qual, usualmente, é mais facilmente compreendida por um ser humano) para a base decimal, basta aplicar a expressão mostrada em \ref{eqBaseNumerica4}.

Um exemplo seria converter um byte (8 bits), cujo conteúdo é igual B11000010 para decimal:

\begin{equation}\label{eqBaseNumerica5}
\begin{split}
Numero_{B11000010 para base decimal} = 1*2^{7} + 1*2^{6} + 1*2^{1} =  193
\end{split}
\end{equation}

Para converter um número na base decimal para a base binária, é necessário realizar a técnica das divisões sucessivas por 2.

Nessa técnica, os dígitos do número binário são obtidos realizando sucessivas divisões por 2 ao número na base decimal. A cada vez que a divisão é realizada, deve-se registrar qual foi o resto da divisão. O processo de divisão por 2 e registro do resto continuará até que a parte inteira da divisão seja igual a 0. 

O número binário resultante da conversão será igual ao restos da divisão tomados na ordem inversa, ou seja, o último resto é igual ao dígito mais significativo e o primeiro será igual ao dígito menos significativo.

A Figura \ref{bin1} mostra um de conversão da base decimal para a base binária. Nesse exemplo, o número 156 é convertido para binário. O resultado da conversão é o número $10011100_{2}$.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{figs/bin1.jpg}
	\caption{Exemplo de aplicação da técnica de divisões sucessivas. }
	\label{bin1}
\end{figure}


\subsection{Subalgoritmos (Funções)}
\label{EmbassamentoSoftware_Funcoes}

Funções são um conjunto de instruções definidas por um nome, argumentos de entrada e argumentos de saída as quais podem ser chamadas e executadas num código apenas escrevendo seu nome junto com seus respectivos argumentos de entrada. 

A sintaxe para definição de uma função é mostrada no código \ref{funcao1}: 

\begin{lstlisting}[ caption =  Sintaxe de definição de uma função, label=funcao1,]

TIPO_SAIDA NOME_FUNCAO(TIPOARG1 NOMEARG1,...,TIPOARGN NOMEARGN)
{
    procedimento1;
    .
    .
    .
    procediemntoN;

	return varivel//( Do tipo TIPO_SAIDA)

}
\end{lstlisting}

Funções são criadas e usadas, principalmente, pelos seguintes motivos:

\begin{itemize}

\item Para permitir o reaproveitamento de código já construído.

\item Para evitar que um trecho de código que seja repetido várias vezes dentro de um mesmo programa.

\item Para permitir a alteração de um trecho de código de uma forma mais rápida. Com o uso de uma função é preciso alterar apenas dentro dela o que se deseja.

\item Para que os blocos do programa não fiquem grandes demais e, por consequência, mais difíceis de entender.

\item Para facilitar a leitura do programa-fonte de uma forma mais fácil.

\item E, principalmente, no paradigma de programação estruturada: para separar o programa em partes(blocos) que possam ser logicamente compreendidos de forma isolada.


\end{itemize}

Um primeiro exemplo de definição de uma função é mostrado no código \ref{funcao2}. Nesse exemplo é definida a função \textit{fatorial}, cujo argumento de entrada é um número inteiro
maior ou igual a 0 e saída é o fatorial do argumento de entrada.

\begin{lstlisting}[ caption =  Exemplo de definição de uma função, label=funcao2,]

/*
funcao fatorial
Objetivo: Calcular o fatorial de um numero inteiro n
Argumentos de entrada - int n 
Argumento de saida - fatorial do numero n
*/

int fatorial(int n)
{	int i;
	int fatorial = 1;
	
	if(n < 0 )
	{	Serial.println("Argumento de entrada inválido")
	return -1;
	}
	else if(n == 0)
	{
		return 1;
	}
	for(i = 1; i<=n;i++)
	{
		fatorial = fatorial * i;
	}

	return fatorial;
}

\end{lstlisting}



A qualquer momento, durante a execução de uma função, que o comando \textit{return} for encontrado, a função será finalizada e o argumento usado juntamente com o \textit{return} será entregue no contexto que a função foi chamada.

O exemplo mostrado no código \ref{funcao2} mostra 3 situações no qual um comando \textit{return} pode vir a ser executado: No primeiro caso, se entrada n for menor que 0, o fatorial não pode ser calculado, então, antes de sair da função é feito um print para avisar no terminal que tal coisa ocorreu. O segundo caso é a possibilidade de a entrada ser igual a 0. Com essa entrada, não se pode fazer o cálculo normal de um fatorial, entretanto a entrada é válida e o resultado é 1. 

Caso a entrada seja positiva e maior que 0, o cálculo normal do fatorial é executado e retornado para onde tal função foi executada.

Um primeiro exemplo de definição de uma função a ser aplicada ns codificação de uma placa como a placa Galileo é mostrado no código \ref{funcao3}. Nesse exemplo 5 aspectos devem ser pontuados:

\begin{enumerate}
	\item \textbf{Prototipos de funções:} A rigor, toda função deve ser declarada antes de poder ser usada, da mesma forma que qualquer variável. Em C, é possível declarar uma função, na forma de protótipo e só definir o seus corpo em um segmento posterior do código. No exemplo \ref{funcao3}, a função lerSensor é prototipada, definindo seu nome, argumentos de entrada e tipo de argumento de saída. Após isso, na função loop, ele é chamada e só no final do código ela é definida.
	\item \textbf{Definição de protótipos de funções:} Toda função prototipada, deve ter seu corpo definido em alguma parte do código.  No exemplo \ref{funcao3}, a função lerSensor é definida no final do código.
	\item \textbf{Escopo de uma variável:}
	 Por escopo de uma variável entende-se o bloco de código onde esta variável é válida. Fora do bloco de código onde a variável foi definida, ela não pode ser acessada. Em C, defini-se um escopo por abrir e fechar chaves ( { } ).	
	\item \textbf{Variáveis locais:}
		Variáveis globais são variáveis visíveis apenas no escopo onde ela foi definida. No exemplo do código \ref{funcao3}, a variável $int sensor$ definida dentro da função lerSensor é visível apenas dentro dessa função.
	\item \textbf{Variáveis globais:}
	Variáveis globais são visíveis por todas funções definidas num código. A variável $int sensor$ definida na linha 2 do código \ref{funcao3} é, ao contrário da variável $int sensor$ definida dentro da função lerSensor, uma variável global, ou seja, ela é visível em todos escopos do programa.
\end{enumerate}

O uso de variáveis globais em C deve ser evitado por que isso quebra a modularização do código, trazendo a possibilidade do funcionamento de uma função interferir no funcionamento de outra. É necessário que o programador tenha exata noção do que está fazendo caso escolha usar variáveis globais.

No caso de programação para micro-controladores como a placa Galileo, o uso de variáveis globais não é tão desaconselhável como para uma programa normal em C. Isso se deve ao fato da existência da função loop.

Um programa escrito para um micro-controlador é feito para atividade contínua. Caso, por exemplo, a variável $int sensor$ fosse definida na linha 11 ( dentro da função loop), a cada ciclo do loop, a variável sensor seria descartada e redefinida, gastando um tempo considerável para aplicações com grandes restrições de tempo de execução. 

\begin{lstlisting}[ caption =  Exemplo de definição de uma função, label=funcao2,]

int lerSensor(int porta);//Prototipo da funcao lerSensor
int sensor//Variavel global: pode ser vista, acessada e editada
          // em qualquer contexto

void setup{

}

void loop{
   //executada a funcao lerSensor com o argumento int porta = 0
   
   sensor = lerSensor(0);// atribui a saida dessa funcao
                         // a variavel global sensor
}

//definicao da funcao lerSensor
int lerSensor(int porta)
{   int sensor;//variavel local, visivel apenas no contexto
				// da funcao lerSensor
				
	sensor = analogRead(porta); 
	return sensor;
}
\end{lstlisting}





\subsection{Interrupção}
\label{EmbassamentoSoftware_Interrupcao}

O fluxo normal de um programa feito para uma plataforma de um microcontrolador é mostrado na Figura \ref{Arduino13}. Como pode ser visto em tal Figura, o programa é iniciado, realiza-se o pré-processamento substituindo as diretivas de compilação, após isso, executa-se a função setup e então a função loop indefinidamente.

Muitas vezes, o fluxo comum de execução de um programa não é capaz de responder a eventos assíncronos externos, causados pelos usuários, ou internos, causados pelo funcionamento do software,  rápido o suficiente.

Para resolver parte desses problemas, existem em computação o que se chama de \textit{interrupção de software} e \textit{interrupção de hardware}. As interrupções são sinal, internos ou externos ao processador, que indicam que o processo corrente deve ser posto em espera e outra tarefa (rotina de interrupção), deve ser executada o mais rápido possível.

A Figura \ref{interrupcao0} resume o processo relacionado a uma interrupção.

\begin{figure}[H]
	\centering
	\includegraphics[width= 0.7\textwidth]{figs/interrupcao0.jpg}
	\caption{Fluxo normal de um programa com uma interrupção.}
	\label{interrupcao0}
	\source{Adaptado de https://www.contec.com/products/daq/analog/basic.php}
\end{figure}

A parte relacionada a \textbf{Salto} é tarefa do sistema operacional ou do micro-controlador. Tendo sido identificada a ocorrência de uma interrupção, o endereço de retorno ao fluxo normal é salvo na pilha de execução e as próximas instruções a serem executadas serão as especificadas na rotina de interrupção.

Após a rotina de interrupção ter sido executada, o endereço de retorno é recolhido da pilha e a execução do programa volta ao fluxo normal.

\subsubsection{Interrupção de Hardware}
\label{intHard}
Uma interrupção de hardware ocorre por um evento assíncrono. Geralmente, tal interrupção é na forma de algum tipo de uma mudança numa entrada analógica ou digital.

As principais formas de interrupção de hardware são as seguintes:

\begin{itemize}
	\item \textbf{Interrupção de rampa de subida}: A interrupção de rampa de subida é identificada pela mudança do estado lido num pino de 0 Volts (GND ou zero lógico) para 5 Volts (Vcc ou 1 lógico). A Figura \ref{interrupcao3} mostra um circuito capaz de oferecer uma rampa de subida à um pino. Quando a chave é fechada, a tensão lida no pino passa de 0 para 5 V.
	\item \textbf{Interrupção de rampa de descida}: A interrupção de rampa de descida é identificada pela mudança do estado lido num pino de 5 Volts (Vcc ou 1 lógico) para 0 Volts (GND ou zero lógico). A Figura \ref{interrupcao2} mostra um circuito capaz de oferecer uma rampa de descida à um pino. Quando a chave é fechada, a tensão lida no pino passa de 5 para 0 V.
	 
	 
\end{itemize}


\begin{figure}[H]
	\centering
	\includegraphics[width= 0.7\textwidth]{figs/interrupcao1.jpg}
	\caption{Interrupções de rampa de subida e descida.}
	\label{interrupcao1}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width= 0.6\textwidth]{figs/interrupcao3.jpg}
	\caption{Circuito associado à interrupção de rampa de subida.}
	\label{interrupcao3}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width= 0.6\textwidth]{figs/interrupcao2.png}
	\caption{Circuito associado à interrupção de rampa de descida.}
	\label{interrupcao2}
\end{figure}

Além das interrupções de rampa de descida e subida, a plataforma Arduino oferece a identificação de interrupções de estado de  qualquer mudança na leitura (CHANGE).

Para a placa Galileo Gen2, apenas as porta digital 2 e 3 podem ser habilitadas para interrupções. 

O código \ref{intecod} mostra, na plataforma Arduino, a sintaxe de definição de uma interrupção de harware. 

\begin{lstlisting}[ caption = Sintaxe para interrupção de hardware,label = intecod0]


void setup()
{
attachInterrupt(NUM_PINO, ROTINA_INT, TIPO_INT);

}


TIPO_RETORNO ROTINA_INT (argumentos de entrada)
{
	//intruções da rotina de interrupção;
}


\end{lstlisting}


Como mostrado no exemplo do código \ref{intecod}, devem ser fornecidas as seguintes informações para definição da interrupção:

\begin{itemize}
	\item \textbf{NUM\_PINO}: Número do pino digital onde a interrupção é lida
	 \subitem 
	 Caso seja a porta digital 2, escrever  attachInterrupt(0, ROTINA\_INT, TIPO\_INT);
	\subitem
	 Caso seja a porta digital 3, escreverattachInterrupt(1, ROTINA\_INT, TIPO\_INT);
	
	\item \textbf{ROTINA\_INT}: Função a ser executada quando a interrução for identifica.
	
	\item \textbf{TIPO\_INT:}
	\subitem RAMPA DE SUBIDA : escrever "RISING".
	\subitem RAMPA DE DESCIDA : escrever "FALLING".
	\subitem Qualquer mudança: escrever "CHANGE".
\end{itemize}    

O código \ref{intecod2} mostra, na plataforma Arduino, um exemplo de uma interrupção de hardware identificada na porta digital 2:

 
\begin{lstlisting}[ caption = Sintaxe para interrupção de hardware,label = intecod0]

int pino = 13;
int estado = LOW;
int estado1 = LOW;
void setup()
{
pinMode(pino, OUTPUT);
attachInterrupt(0, piscaLed, FALLING);
}
                                                               
void loop()
{
digitalWrite(pino, estado);

}

//FUNCAO A SER EXECUTADA AO SER IDENTIFICADA UMA RAMPA DE //DESCIDA NA PORTA DIGITAL 2(2 -> 0)
void piscaLed()
{
if(estado==estado1)
{
estado = !estado1;
//DELAY NECESSARIO PARA EVITAR RUIDOS NA PORTA DIGITAL 2
delay(10);
}
else
{
//DELAY NECESSARIO PARA EVITAR RUIDOS NA PORTA DIGITAL 2
delay(10);
estado= estado1; 
}
}
\end{lstlisting}



\subsubsection{Interrupção de Software - Timer}

Interrupção de Software são interrupções disparadas por eventos que ocorrem no software em execução.

Um Timer obedece o mesmo padrão mostrado na Figura \ref{interrupcao0}, entretanto, o evento que disparará a interrupção não será um evento de harware, mas a contagem de pulsos de clock.

\textit{Timers} são contadores de tempo. A cada intervalo prefixado, os \textit{Timers} tem seu contador incrementado, indicando, desde o início da contagem, quantos pulsos de clock foram lidos desde então. Quando o número de pulsos de clock limite for atingido, a rotina de interrupção (\textit{Interruption Service Routine - ISR}) deve ser executada e o contador do Timer será reinicializado.

Para uso de interrupções na plataforma Arduino, é necessário realizar o download da biblioteca \textit{Timer1.h}

Para realizar o download, visite o website \textit{http://playground.arduino.cc/Code/Timer1} como mostrado na Figura \ref{timer2}.

\begin{figure}[H]
	\centering
	\includegraphics[width= 0.7\textwidth]{figs/timer2.jpg}
	\caption{Website - http://playground.arduino.cc/Code/Timer1 .}
	\label{timer2}
\end{figure}

Clique no link para downloads mostrado na Figura \ref{timer3} e siga as seguintes instruções:

\begin{itemize}
	\item Descompacte os arquivos do arquivo.zip
	\item Crie a pasta Arduino/hardware/libraries/Timer1		
	\item Copies os arquivos descompactados para a pasta criada
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width= 0.9\textwidth]{figs/timer3.jpg}
	\caption{Download e instruções para instalação da biblioteca Timer1.}
	\label{timer3}
\end{figure}

Tendo instalado propriamente a biblioteca \textit{Timer1.h}. Para uso de interrupção de timers em Arduino, os seguintes passos devem ser seguidos:

\begin{enumerate}
	\item Definição do período no qual o timer disparará uma interrupção, executando uma ISR -> função \textit{initialize}
	\item Definição da ISR que será executada a cada período especificado 
	\item Vinculação da ISR ao Timer -> função \textit{attachInterrupt}
\end{enumerate}

O código \ref{timer10} mostra um exemplo de como utilizar a biblioteca \textit{Timer1}

\begin{lstlisting}[ caption = Sintaxe para interrupção de hardware,label = timer10]

#include <TimerOne.h> //Inclusao da biblioteca

void setup() 
{
pinMode(13, OUTPUT); //Inicializando o pino 13 como saida

Timer1.initialize(100000); // seta o timer para o periodo
							// 100000 microsegundos (0.1 s - // //10Hz) => a ISR serah executada 10 //vezes por segundo 

Timer1.attachInterrupt( ISR_EXEMPLO, 100000  ); //Vincula a ISR
										// ISR_EXEMPLO ao timer
										// de 0.1 segundos a ser executada //todas vez que o timer for //completo (caso fosse escrito //200000 a ISR executada na //segunda vez que o timer for //completo)
}

void loop()
{
//Fluxo normal do programa( sem ser a interrupcao de timer)
}

void ISR_EXEMPLO()
{
// Pisca LED
// o operado ^ eh o XOR, a cada execucao desta ISR, o estado do // LED (acesso ou apagado) eh invertifo
digitalWrite( 13, digitalRead( 13 ) ^ 1 );
}

\end{lstlisting}


As funções da biblioteca \textit{Timer1.h} tomam os parâmetros de tempo em microsegundos, como mostrado no exemplo \ref{timer10}.




Nesse exemplo, a cada 100000 microsegundos, ou 0.1 segundos, a função ISR\_EXEMPLO, que foi vinculada ao timer por meio da função \textit{attachInterrupt()}, é executada, independentemente do que estiver ocorrendo no fluxo normal da função loop.

\subsection{Numero randômico}

Muitas vezes, num sistema computacional, faz-se necessário a geração de números aleatórios para definição de parâmetros de execução de um programa. 

Número aleatórios têm aplicações em: Jogos de apostas, simulações computacionais, criptografia e outras áreas onde um resultado não predizível se faz necessário.

O principal problema para geração de números aleatórios num sistema computacional é que tais sistemas são, por suas naturezas, completamente determinísticos. Um sistema determinístico não pode, realmente, gerar números aleatórios, pois, para fazê-lo, o sistema seguirá sempre os mesmos passos determinados em seus algoritmos. Dessa dificuldade nasce o termo \textit{número pseudo-aleatório}, o qual se dá a números gerados por sistemas computacional.

Uma maneira, em Arduino, para gerar um número pseudo-aleatório é utilizando o comando \textit{random()}. O código \ref{rand0} mostra os modos de uso da função \textit{random()}   

\begin{lstlisting}[ caption = Exemplo de geração de um número aleatório usando o comando random(),label = rand0]
int random1 = random(1000); //gera um numero pseudo-aleatoria entre 0 e 999
int random2 = random(10,30); //gera um numero pseudo aleatorio entre 10 e 29
\end{lstlisting}

Uma das maneiras de contornar a característica determinística de um algoritmo de geração de número pseudo-aleatório é adicionar um parâmetro determinado por uma característica física ao algoritmo como tempo ou uma leitura analógica de uma variável.

Em Arduino, uma das maneiras de se adicionar ao algoritmo de geração de números aleatórios um parâmetro físico é utilizando o comando \textit{randomSeed()}. O comando \textit{randomSeed()} inicializa o gerador de números aleatórios a depender do valor passado como argumento. O código \ref{rand1} mostra uma entrada de uma porta analógica em aberto como argumento para o comando \textit{randowmSeed()}. Ao se ler uma porta analógica desconectada de um circuito tem-se um valor flutuante determinado apenas por ruídos aleatórios. 


\begin{lstlisting}[ caption = Exemplo de geração de um número aleatório usando o comando random() e randomSeed(),label = rand1]
void setup()
{
	Serial.begin(9600);
	int pinoAnalogicoNaoUtilizado = 3; //Numero de um pino analogico nao utilizado (pino em aberto)
	randomSeed(analogRead(pinoAnalogicoNaoUtilizado));// geracao de um sequencia de numeros a depender de uma variavel aleatoria do pino analogico em //aberto
}

void loop()
{
int random1 = random(1000); //gera um numero pseudo-aleatoria entre 0 e 999 utilizando o randomSeed() para inicializar a sequencia de numero aleatorios
int random2 = random(10,30);//gera um numero pseudo aleatorio entre 10 e 29 utilizando o randomSeed() para inicializar a sequencia de numero aleatorios

delay(20);
}

\end{lstlisting}

\subsection{Funções e Bibliotecas Diversas - Arduino}
\label{EmbassamentoSoftware_FuncoesArduino}

\subsubsection{Função shiftOut}
\label{shiftOut}

A função shiftOut tem a seguinte sintaxe:

$shiftOut(dataPin, clockPin, bitOrder, value);$

Ela é destinada a transmitir uma série de bits (variável \textbf{value}), numa porta selecionada (variável \textbf{dataPin}), um bit de cada vez seguindo os pulsos de clock (variável \textbf{clockPin}). 

A transmissão ocorre em bytes,bit a bit. Tal transmissão pode ocorrer a partir do bit mais significativo ou a partir do bit menos significativo. Para escolher qual das duas opções será escolhida deve-se usar \textbf{MSBFISRT} ou \textbf{LSBFIRST}, no argumento \textit{bitOrder}, respectivamente.   

O código \ref{shiftOut1} mostra um exemplo de uso da função shiftOut.

\begin{lstlisting}[ caption = Exemplo de uso da função shiftOut, label=shiftOut1,]
#define pinoClock  7
#define pinoLatch  6
#define pinoData  5

byte numeroOut = 154;// byte = 8 bits


void setup() {
pinMode(pinoLatch, OUTPUT);
pinMode(pinoClock, OUTPUT);
pinMode(pinoData, OUTPUT);
}

void loop() {

digitalWrite(pinoLatch, LOW);

// envia dados nos pinos de saida a partir do bit menos significa
//tivo da variavel numeroOut no pinoData

shiftOut(pinoData, pinoClock, LSBFIRST, numeroOut);  


digitalWrite(pinoLatch, HIGH);
}

\end{lstlisting}

\subsubsection{Biblioteca ledcontrol.h}

A biblioteca ledcontrol.h deve ser usada em conjunto com os chips MAX7221 e MAX7219 que controlam displays de leds. 

Para baixar e instalar a biblioteca ledcontrol.h, o seguintes passos devem ser seguidos:

\begin{enumerate}
	\item Abra a \textit{General User Interface} (GUI) do Arduino
	\begin{figure}[H]
		\centering
		\includegraphics[width= 0.7\textwidth]{figs/ledcontrol0.jpg}
		\caption{GUI do Arduino aberta.}
		\label{ledcontrol0}
	\end{figure}
	\item Tendo aberto a GUI do Arduino, clique na aba \textit{Manage libraries} que pode ser encontrada seguindo o seguinte caminho: Sketch/	Include Libraries/Manage Libraries...
		\begin{figure}[H]
			\centering
			\includegraphics[width= 0.7\textwidth]{figs/ledcontrol1.jpg}
			\caption{Caminho para a aba \textit{Manage Libraries}.}
			\label{ledcontrol1}
		\end{figure}
	\item Será mostrada a janela \textit{Library Manager} apresentada na Figura \ref{ledcontrol2}
		\begin{figure}[H]
			\centering
			\includegraphics[width= 0.7\textwidth]{figs/ledcontrol2.jpg}
			\caption{Janela \textit{Manage Libraries}.}
			\label{ledcontrol2}
		\end{figure}
	\item Digite \textit{LedControl} no campo de texto localizado na parte superior.
		\begin{figure}[H]
			\centering
			\includegraphics[width= 0.7\textwidth]{figs/ledcontrol3.jpg}
			\caption{Resultado da busca por \textit{LedControl}.}
			\label{ledcontrol3}
		\end{figure}
	\item Clique no resultado da busca e, após isso, clique em \textit{Install}.		
		\begin{figure}[H]
			\centering
			\includegraphics[width= 0.7\textwidth]{figs/ledcontrol4.jpg}
			\caption{Clique no \textit{Install}.}
			\label{ledcontrol4}
		\end{figure}
	\item Após tais passos, a biblioteca \textit{LedControl.h} estará instalada.
	\begin{figure}[H]
		\centering
		\includegraphics[width= 0.7\textwidth]{figs/ledcontrol5.jpg}
		\caption{Biblioteca LedControl.h instalada.}
		\label{ledcontrol5}
	\end{figure}
	
\end{enumerate}


Para biblioteca LedControl servirá para facilitar controle de uma matriz de LEDs em conjunto com o circuito integrado MAX7219.

O código \ref{LEDCONTROL0} mostra os passos para o suo da biblioteca. Nesse código, todos led de uma matriz 8x8 são acessos e apagados iterativamente.


\begin{lstlisting}[ caption = Exemplo de uso da biblioteca LedControl.h, label=LEDCONTROL0,]

#include "LedControl.h" //  need the library
LedControl lc=LedControl(12,11,10,1); // 

// pino 12 conectado ao pino 1 do  MAX7219 
// pino 11 conectado ao pino 13 CLK 
// pino 10 conectado ao pino 12 LOAD
// O número 1 indica que 1 MAX7219 será usado

void setup()
{
	// O número 0 como o primeiro argumento de muitas funções
	// da biblioteca LedControl.h indica o uso de 1 chip MAX7219 
	
	lc.shutdown(0,false);// Desliga o modo de economia de energia, 	//habilita o display
	
	lc.setIntensity(0,8);// seta a claridade (input entre 0 e 15)
	lc.clearDisplay(0);// limpa o display
}
void loop()
{
	for (int linha=0; linha<8; linha++)
	{
		for (int coluna=0; coluna<8; coluna++)
		{
			lc.setLed(0,coluna,linha,true); // liga o LED na //posicao(linha, coluna)
			delay(25);
		}
	}
	
	for (int row=0; row<8; row++)
	{
		for (int col=0; col<8; col++)
		{
			lc.setLed(0,col,row,false); // desliga o LED na 
			//posicao(linha, coluna)			
			delay(25);
		}
	}
}

\end{lstlisting}


